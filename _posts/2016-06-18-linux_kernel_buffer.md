---
title: "linux之提高文件I/O效率"
layout: post
category: kernel
---

# 缓冲区的大小对性能的影响

对大小是2500字节的文件进行copy操作，

	如果缓冲区大小是100字节，需要25次read()和write()；

    如果缓冲区大小是1000字节，需要3次read() 和write()


# 系统调用的影响

缓冲区之所以对文件I/O性能有着显著的影响，这是因为每一次的read()、write()操作
必须经过系统调用，也就是内核访问。用户空间的程序每次必须经过内核才可以访问位
于 磁盘上的文件。

# 思路

引入缓冲区，就是不必每次访问系统呼叫，只需一次调用，将内容放入缓冲区，每次用
户空间的程序可以访问缓冲区的内容，直至缓冲区的内容被消耗掉。

[举个例子](!https://github.com/yuzibo/linux-programming/blob/master/unix_linux_programming/ch1/utmplib.c)

# 内核使用缓冲技术吗

使用。磁盘是数据块集合，内核会对磁盘上的数据块作缓冲。内核将磁盘上的数据块复
制到内核缓冲区中，当一个用户空间中的进程要从磁盘上读取数据时，内核一般不直接
读磁盘，而是将内核缓冲区中的数据复制到进程的缓冲区中。

当进程所要求的数据块不在内核缓冲区中，内核会把相应的数据块加入到请求数据列表中，然后把该进程挂起，接着为其他进程服务。

一段时间后，内核把相应的数据块从磁盘读到内核缓冲区，然后再把数据复制到进程的缓冲区中，最后唤醒被挂起的进程。

# open/read/write 和fopen/fread/fwirte

大约不久前，我突然接触open的时候，也在想之前是不是接触过一个fopen函数，这两
个函数有什么区别，或者为什么有两个形式？看了上面的铺垫，想必你也有想法了，对
，或者说，这是很重要的一方面。

open系列函数与fopen系列的区别可以简单概括为：

<pre>
open系列函数										 fopen系列函数
一般用于打开设备文件（少数情况）          一般用于打开普通文件（大多数情况）

利用文件描述符操纵文件(int)							 利用文件指针操作文件
open返回一个文件描述符							fopen返回一个文件指针
POSIX系统调用										ANSI C库函数
低层次IO										高层次IO，对open的扩展和封装
只能在POSIX操作系统上 
可移植到任何操作系统
非缓冲IO			     							 缓冲IO
只能读取二进制或普通文   						可以读取一个结构
可以指定要创建文件的访 限					不能指定要创建文件的访问权限
</pre>

注: 文件指针的类型为 F *fp;

总结一下，就是带f前缀的是库函数，操作对象是file stream，不带f的原生态的
操作是unix下的系统调用。

用C标准I/O库函数要时刻注意I/O缓冲区和实际文件有可能不一致，在必要时需调用fflush(3)。

又因为c标准库函数是C标准的一部分，而Unbuffered I/O函数是UNIX标准的一部分，前者放在<stdio.h>文件中，后者放在<unistd.h>,从文字上你就可以知道什么意义了。

其实还有一个函数也是比较重要的，尤其是确保内核内的数据写入磁盘，这个函数就是

```c
#include<unistd.h>
void sync(void)
```
还有一个函数也是非常重要的

```c
#include <unistd.h>
int fsync(int fd);
int fdatasync(int fd);
```


