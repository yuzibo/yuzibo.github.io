---
title: rust之入门
category: rust
layout: post
---
* content
{:toc}

# install
首先要根据官网的指令把rust安装到pc上，其包管理器是Cargo.

# hello world

```rust
fn main() {
    println!("hello, world");
}
```
保存为文件为 hello.rs.  然后使用命令`rustc hello.rs`去编译生成hello的二进制文件。

# 注释
rust的注释有三种，其中"/**/"和"//"与c/c++的注释方式一致，第三种方式是

```bash
/// Doc which are parsed into html, begin
//! end
```

# 格式打印
上面的println!就是将文本打印到console上并换行。

```rust
   println!("{ } days", 31);
   println!("{0}， this is {1}, {1} this is {0}", "yubo", "hechun");
```
"{}"会自动替换任何参数。指示词可以使用0和1自动填入参数,这样的参数在这里叫做位置参数Positional arguments。

还可以有 Named arguments. 比如下面这种:
```rust
	// name arg:
	 println!("{sub} {verb} {obj}",
            obj="vimer",
            verb="hello",
            sub = "test");
   // {:b} print it with binary format
   println!("{} of {:b} know binary, the other half does not", 1, 2);

   // Right-align text with a special width
   println!("{number:>width$}", number=1, width=6);
```

output:

```bash
test hello vimer
1 of 10 know binary, the other half does not
     1
```

```rust
 // Right-align text with a special width
   println!("{number:>width$}", number=1, width=6);

   println!("{number:>0width$}", number=1, width=6);
/*
1 of 10 know binary, the other half does not
     1
000001
*/
```

以上的代码中，包含了格式(二进制b，对其， 填充)等格式说明。

如果位置参数确实怎么办？ rust会直接给你报错。

```rust
 println!("my name is {0}， and your name is {1}, {1} this is {0}", "vimer");
```

error:

```bash
error: invalid reference to positional argument 1 (there is 1 argument)
 --> hello.rs:2:47
  |
2 |    println!("my name is {0}， and your name is {1}, {1} this is {0}", "vimer");
  |                                                ^^^  ^^^
  |
  = note: positional arguments are zero-based

error: aborting due to previous error
```
## debug

 "{:?}" to debug rust program


# type
 Rust的类型比较特殊，是需要值得注意点。

```rust
fn main() {
    // Variables can be type annotated.
    let logical: bool = true;

    let a_float: f64 = 1.0;  // Regular annotation
    let an_integer   = 5i32; // Suffix annotation

    // Or a default will be used.
    let default_float   = 3.0; // `f64`
    let default_integer = 7;   // `i32`

    // A type can also be inferred from context
    let mut inferred_type = 12; // Type i64 is inferred from another line
    inferred_type = 4294967296i64;

    // A mutable variable's value can be changed.
    let mut mutable = 12; // Mutable `i32`
    mutable = 21;

    // Error! The type of a variable can't be changed.
    mutable = true;

    // Variables can be overwritten with shadowing.
    let mutable = true;
}
```

 下面的代码把rust基本的数据总结下来了:

```rust
fn main() {
   println!("1+2={}", 1u32+2); // 3
   println!("1-2={}", 1i32-2); // -1
   println!("true and false is {}", true && false);// true and false is false
   println!("true or false is {}", true || false); // true or false is true
   println!("Not true is {}", !true); // Not true is false
    // bitwise
    println!("0011 AND 0101 is {:04b}", 0b0011u32 & 0b0101u32); //0011 AND 0101 is 0001
    println!("0011 or 0101 is {:04b}", 0b0011u32 | 0b0101u32);//0011 or 0101 is 0111
    println!("0011 XOR 0101 is {:04b}", 0b0011u32 ^ 0b0101u32); //0011 XOR 0101 is 0110
    println!("1 << 5 is {}", 1u32 << 5); // 1 << 5 is 32
    println!("0x80 >> 2 is {:x}", 0x80u32 >> 2); //
    println!("One million is written as {}", 1_000_000u32);// One million is written as 1000000
}
```

# mut
该修饰符可以改变变量的属性，主要是否可以改变其值的属性。

