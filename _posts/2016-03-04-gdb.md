---
title: "gdb调试举例"
layout: article
category: tools 
---

# 终于有机会总结gdb了

# 下面的这个程序我还弄不明白,继续debug

```c
#include<stdio.h>
int main()
{
	int a[5] = { 1,2,3,4,5};
	int *ptr1 = (int *)(&a + 1);
	int *ptr2 = ((int *)(int)a + 1);
	printf("%x,%x",ptr1[-1],*ptr2);
	return 0;
}
```
# list命令

### list num

显示源代码的num行的周围几行。

### list function
显示函数。

# p命令

### 打印结构体元素

使用这个命令，还可以查看结构体的各元素值

> p *pstDate

### 打印数组元素

如果你想查看一个数组的各个元素，别像我似的傻乎乎的一个个 p a[i],节省生命的做
法应该是：

>p ArrayVal@itemnum

什么意思？意思就是打印数组ArrayVal的前itemnum个元素。

### 格式控制

	p /x Val    十六进制 

	  /c		字符？

	  /f		浮点型？

### 查看内存变量

> x

我也不知道这一个有什么作用现在为止

### 查看局部变量

info local

# run

## set args num1 num2 num3 ..
使用show args查看设置的参数。

# break

## break function

## break lines

## break filename:linenum
在源文件filename的linenum行设置断点

## break filename:function
在源文件的filename的function设置断点

## break *address
在程序运行的内存空间地址处停住.

## break
没有参数时，表示在下一条指令处停住。

## break if <condition>
比如，设置

>break if i = 10;

就是在循环体内当i等于10的时候停住。

方便一点的话，可以使用

>filename:line_numbers if i == 5

比如， 我想在文件gdb.c的循环体for内当I等于5的停下来，则：

```c
break gdb.c:6 if i == 5
```


# 单步执行 next和step

在调用函数的那行，设置个断点，然后step就进入函数体内。
扩展的用法是next<count>和step<count>

# finish
运行程序直到当前函数完成返回，并打印函数的返回时的堆栈地址、返回值及参数值。

## until
使用until退出循环体。这一条十分重要哈^_^.

## stepi(si) 和nexti(ni)
stepi用于单步跟踪一条机器指令，另外使用

>display/i $pc

在打印出程序代码的同时打印出机器指令。

# watch
watch <exp> 为表达式exp设置一个观察点，一旦表达式的值发生变化，马上停止程序运行。

rwatch <expr> 当表达式被读时，停止程序运行。

awatch <expr> 当表达式的值被读或者被写时，停止程序运行。

info watchpoints: 列出当前所设置的所有观察点。

# 查看函数体内的变量值

当我们使用 s 命令进入函数体内时，除了简单的 p 打印，还要更加丰富些，比如，使用backtrace(bt)

```c
(gdb) bt
#0  add_range (low=1, high=10) at main.c:6
#1  0x080483c1 in main () at main.c:14
```
从这里可以看出add_range()函数是main函数调用的，main传进来的参数是low=1，high=10，main的帧为1，add_range()的帧为0，使用i(info)来看函数局部变量的值。

如果想查看main函数的当前局部变量也可以，先使用frame(f)命令,选择1号栈再查看局部变量的值：

```c
(gdb) f 1
#1  0x080483c1 in main () at main.c:14
14		result[0] = add_range(1, 10);
(gdb) i locals 
result = {0, 0, 0, 0, 0, 0, 134513196, 225011984, -1208685768, -1081160480, 
...
  -1208623680}
```

# 一次性查看结构体各个成员的值

比如，我有一个结构体结构是这样的：

```c
/*一个有权值的边集在图中*/
 struct Edge{
 	int src, dest, weight;

 };

 /* V: 顶点数 E：边数,无向图*/
 struct Graph{
 	int V,E;
 	struct Edge* edge;
 };
```

先定义一个graph,在完成一次loop操作后，这时我想查看其中的各个域的值，可以一次一次的使用：

>p graph@v 

等进行查看，不过这样查看效率可是不高，所以在gdb中，需要使用脚本：

```bash 
(gdb) set $i=5
(gdb) while ($i!=0)
 >print graph->edge[$i]
 >set $i = $i - 1
 >end
$5 = {src = 2, dest = 4, weight = 7}
$6 = {src = 4, dest = 1, weight = 6}
$7 = {src = 0, dest = 4, weight = 5}
$8 = {src = 49, dest = 0, weight = 0}
$9 = {src = 3, dest = 2, weight = 4}
```



