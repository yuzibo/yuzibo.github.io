---
title: "sort排序"
category: DS
layout: article
---
# 一 摘要
排序算法是很重要的在计算机科学中。

# 二 各种排序算法的实现
这里，性能的分析最后补上，因为自己的数学实在差劲。

## 2.1合并排序

[code](https://github.com/yuzibo/DS/blob/master/sort/merge.c)
这里的合并排序只是简单的使用一个数组，没有考虑两个数组的情况，其实是一样的。
请记住，在执行完两个子数组的其中任何一个接下来执行的操作，这才是重点。参数
为你要排序的数组、起始位、中间位、结尾。

## 2.2交换排序

###  bubble sort
所谓的冒泡排序大家都听说过，这里直接上代码，不过你要注意那个标志符的作用。我
还是在老地方犯错：先是一个while、接着for，之间填一个sorted=1;这样效率上会有
提升。

```c
/*我的困难局限于标志变量的位置*/
void bubblesort(int a[],int n){
	int i,j,temp,sorted;
	i = sorted = 0;
	while( (i < n - 1) && (!sorted)){
		sorted = 1;
		for(j = n - 1; j > i; j--){
			if(a[j] < a[j-1]){
				temp = a[j];
				a[j] = a[j-1];
				a[j-1] = temp;
				sorted = 0;
			}
		}
	}
}
```

## 2.3 插入排序
插入排序分为直接插入排序和希尔排序

### 插入排序
将一个记录插入到已排序良好的有序表中，从而得到一个记录数增加1的新表，直到整
个表有序为止。

#### 要点：
设立哨兵，作为临时存储和判断数组边界之用。
最难的是确定插入的位置，在思维上的模糊感还是特别强。

```c
void insert_sort(int a[],int n){
	int i,t;
	int tmp;
	for(i = 1; i < n; i++){ // 只需注意后一项比前一项大的即可
		if(a[i] < a[i-1]){
			t = i - 1;	// 先前移一个元素？这里快想透了
			tmp = a[i];
			a[i] = a[i-1];
			while(tmp < a[t]){ //寻找在有序表插入的位置

				a[t+1] = a[t];
				t--;
			}
			a[t+1] = tmp; //将哨兵元素放入其中
		}
	}
}
```
我自己写的时候的模糊点：

1. 首先前移一位；
2. 寻找在有序表的位置及移动的方法及将哨兵放入排序后的空缺位置

#### 效率
O(n^2).

