---
title: "Makefile 知识点"
layout: article
category: make
---

## 本文参考众多资料汇总而成，如有侵权，请告知

# <<>跟我一起写Makefile陈皓>

Makefile中的$(CFLAGS)是什么意思？

Makefile文件
==================
CC=gcc

LIBS=-L/usr/lib/mysql -lmysqlclient

svrRegister: reg_app.c Sdbconn.o utilities.o 
        $(CC) -o svrRegister $(CFLAGS) Sdbconn.o utilities.o  reg_app.c  $(LIBS)
        cp -a svrRegister /var/www/cgi-bin/

这里也包含了怎样连接库函数的用法

# 详细看一个例子

objects = foo.o bar.o
all: $(objects)

$(objects): %.o: %.c
$(CC) -c $(CFLAGS) $< -o $@

这里重点介绍下这几个变量的使用方法：

%.o是 $objects的目标集合，也就是所有的.o文件，但是这几个文件又依赖前面的%代
表的文件，只不过又加上了.c.而命令中的"$<"代表所有的目标依赖文件，$@代表所有
的目标文件。

# 自动生成依赖性
使用"-M"选项自动包含源程序持有的头文件。在GNU下，使用"-MM"才可以，前者包含了
所有的文件。
那么，在Makefile是不是也这样调用呢，不是的。我们把自动生成的依赖文件放到一个
文件中去。为每一个"name.c"的文件都生成一个"name.d"的Makefile文件，[.d]文件
中就存放着对应的[.c]文件的依赖关系。

````Makefile
%.d: %.c
	@set -e; rm -f $@; \
	$(CC) -M $(CPPFLAGS) $< > $@.$$$$; \
	sed's \($*\)\.o[ :]*,\1.o $@ : ,g' < $@.$$$$ > $@; \
	rm -f $@.$$$$
```
这个规则的意思是所有的[.d]文件依赖于 [.c]文件，"rm -f $@"的意思是删除所有的
目标文件，也就是[.d] 文件，下面一行是将目标依赖文件($<)所生成目标文件($@)，
然后以 $$$$后缀，也就是随机数，比如name.d.1234.下面的sed后来讲

总的讲，就是在编译器生成的依赖关系中加入[.d]文件的依赖，
TODO...

# 命令书写
每条命令的书写必须以[tab]键开头，除非，命令是紧跟在依赖规则后面的分后[;]的。

[@]不向屏幕输出命令，例如，"@echo 正在编译模块" 这时输出到屏幕的信息为"正
在编译模块" 如果去掉 @,那么会显示出来"echo 正在编译模块"

[-n 或者 --just-print]	那么只会显示命令，不会执行命令，
[-s 或者 --silent]	 则是全面禁止命令的显示。

# 命令执行
Makefile的命令是一条一条执行的，但是，如果你想把上一条执行的语句放到下局中
执行，那么必须使第二句以";"紧跟在第一句的后面

# 命令出错
Make每执行一条语句的时候，总会返回一个执行码，如果正确执行的话，返回0，出错
返回非0的数字，而且还中断程序的执行，那么，我们在命令的前面加上"-", 则可以消
除这个强制退出，

# 嵌套执行
linux kernel下的各个子目录都有自己的Makefile，要这么写：

```Makefile
subsystem: 
	cd subdir && $(MAKE)
```
上面的语句等价于

```Makefile
subsystem:
	$(MAKE) -C subdir
```
这里，“-C”是改变目录的意思:这里都是首先进入subdir 子目录，然后执行make 命令
。
最顶层的Makefile中的变量可以传递给下级的Makeflie,但是不会覆盖子目录的Makefli
e中定义的变量

1. 传递给下级

> export <variable>

2. 不想传递给下级

> unexport <variable>
这里有两个系统级别的变量：SHELL和MAKEFLAGES,尤其是后者，这是一个系统级别的变
量。

3. -w
 这个选项是打印当前的目录，比较有用的 .使用"-C"选项的话，这个选型自动打开。

4. 定义命令包

还是为了简化Makefile的书写；

```makefile
define run-yacc
	yacc $(firstword $^)
	mv y.tab.c $@
endef

foo.c : foo.y
	$(run-yacc)

```
上面的这段就是简单的一个命令包，命令行中的“$^”就是"foo.c",因为yacc的程序总会
生成y.tab.c的文件，所以第二行的命令就是把这个文件改名。

# 变量
Makefile的变量是大小写敏感的，不能有空格,"#","="等
变量在声明的时候要给予初值，需要的时候使用$前面加上"()" 或者 "{}",若使用真实
的$,则应该为$$

1. 变量值的替换
$(var :a=b)
看一个例子：
```Makefile
foo := a.o b.o c.o
bar := $(foo:.o=.c)
```
我们先定义了个$(foo),而bar := $(foo:.o=.c)就是把所有以 ".o"字符串全部替换成
".c"，如此我们的 $(bar)的值为"a.c b.c c.c"

2. "+="
追加变量符

3. "-e"
系统环境的变量会覆盖Makefile的变量

4. 模式变量
make的 "模式"一般是至少含有一个"%"的
 %.o:CFLAGS = -O

# 条件判断
```Makefile
ifeq ($(CC), gcc)
	$(CC) -o foo $(objects) $(xx)
else
	$(CC) -o foo $(objects) $(yy)
endif
```
# 函数的调用语法

> $(<function> <arguments>)

参数间以","分开。函数与参数之间使用空格分开
常用的函数有：

1. subst

 $(subst <from>,<to>,<text>)

把字符串<text>中的<from>字符串替换成<to>

2. patsubst

$(patsubst <pattern>,<replacement>,<text>)

这两个函数全都是在字符串的末尾

```Makefile
$(patsubst %.c,%.o,x.c.c bar.c)
```
把字串"x.c.c bar.c" 符合模式[%.c]的单词替换成[%.o],返回结果就是"x.c.o bar.o"

3. strip 去空格

>$(strip <string>)

去掉<string>字符串开头和结尾的空字符
 
4. findstring

>$(findstring <find>,<in>)

在<in>字符串中查找<find>字符串，若找到，则返回<find>,否则为空

5. filter

>$(filter <pattern>,<text>)

就在在<text>中保留符合<pattern>的文件。

``` Makefile
sources := foo.c bar.c baz.s ugh.h
foo :$(sources)
	cc $(filter %.c %.s,$(sources))  -o foo
$(filter %.c %.s,$(sources))
```
则结果返回foo.c bar.c baz.s 也就是过滤出来

6. filter-out
反过滤函数，作用与上面的函数相反

7. sort
将变量排序，而且挤掉相同的文本・

8. word 

>$(word <n>,<text>)

从text文本中选取第n个单词 

9. wordlist

>$(wordlist <s>,<e>,<text>)
从text中选取从s到e的单词

10. words

> $(words <text>)

统计text中单词的个数

11. firstword

# 文件名操作函数

1. dir
>$(dir <name...>)

返回文件所在的目录

2. notdir

>$(notdir <names...>)

与上面的例子相反，只是返回最后一个文件名

3. suffix

>$(suffix <names...>)

返回文件类型的后缀，如果没有的话，返回空值

4. basename

取前缀，复合路径的话返回路径

5. addsuffix

>$(addsuffix <suffix>,<names...>)

把后缀加到每个单词后面

$(addsuffix  .c, foo bar) 返回值是"foo.o bar.o"

6. addprefix

$(addprefix <prefix>,<names...>)

7. join

$(join <list1>, <list2>)

有点复杂，先看个例子：

$(join aaa bbb, 111 222 333),返回值是"aaa111 bbb222 333"

# foreach

$(foreach <var>,<list>,<text>)

# origin
判断一个函数是否定义过，从哪里定义来的，定义的什么

# 自动化变量

## $@
表示规则中的目标文件集，在模式规则中，那么， "$@"就是匹配于目标中模式定义的
集合。

## $%
仅当目标是函数库文件时，表示规则中的目标成员名。

## $<

依赖目标中的第一个目标文件。

## $?
所有比目标新的依赖目标的额集合。以空格分隔。

## $^
所有的依赖目标的集合，以空格分隔，如果在依赖目标中有多个重复的，那这个变量
就会去除重复的依赖目标，只保留一份

## $+ 
这个变量很像"$^",只不过不去除重复的依赖目标。






