---
title: "unix之exec"
category: unix
layout: article
---

在unix中，一个shell的执行流程如下：

时间轴
------------------------>>

读入命令
      ___                    ____
sh----|  |-------------------|   |
 ^    |__|                   |___|
 |      |    新进程            |
 |      |____>"ls"--->退出     |____>"ps"
"ls"

# 一个程序如何运行另一个程序？

使用execvp，这个函数有两个参数：要运行的程序名称和这个程序的命令行参数组。当程序运行时命令行参数以argv[]的形式传递给程序. <font color="#FF0000"> 注意，将数组的第一个元素设置为程序的名称，最后一个元素必须是Null. </font>

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main()
{
	char *arglist[3];

	arglist[0] = "ls";
	arglist[1] = "-l";
	arglist[2] = 0;
	printf("***中断这个程序的执行***\n");
	execvp("ls", arglist);
	printf("ls is done, bye\n");
}
```

```bash
yubo@debian:~/test/tmp/unix/shell$ ./exec
***中断这个程序的执行***
总用量 88
-rwxr-xr-x 1 yubo yubo  6108  5月 18 06:40 exec
-rw-r--r-- 1 yubo yubo   407  5月 18 07:08 exec1.c
-rw-r--r-- 1 yubo yubo   801  5月 16 19:28 execute.c
-rw-r--r-- 1 yubo yubo 29520  5月 16 19:05 segfault
-rwxr-xr-x 1 yubo yubo 13680  5月 16 19:30 smsh
-rw-r--r-- 1 yubo yubo   811  5月 16 19:30 smsh1.c
-rw-r--r-- 1 yubo yubo   389  5月 16 19:09 smsh.h
-rw-r--r-- 1 yubo yubo  2630  5月 16 19:30 splitline.c
-rwxr-xr-x 1 yubo yubo  6188  5月 16 19:49 test
-rw-r--r-- 1 yubo yubo   265  5月 16 19:48 test.c
```

这里你有没有注意到上面程序中的第二条printf语句消息了。这里书上的解释是：内核将新进程载入到当前进程，替换了当前进程的代码和数据，也就是说，execvp这个函数将“ls”这个命令加入到当前的程序，代替了后面的语句，从而使后面的printf语句消失掉。



