<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>vimer</title>
    <meta name="description" content="">

    <link rel="shortcut icon" href="/favicon.ico?" type="image/x-icon">
    <link rel="icon" href="/favicon.ico?" type="image/x-icon">
    <link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://at.alicdn.com/t/font_8v3czwksspqlg14i.css">
    <link rel="stylesheet" href="/css/main.css ">
    <link rel="canonical" href="http://0.0.0.0:4000/page31/">
    <link rel="alternate" type="application/rss+xml" title="vimer" href="http://0.0.0.0:4000/feed.xml ">





</head>


  <body>

    <header id="top">
    <div class="wrapper">
        <a href="/" class="brand">vimer</a>
        <small>linux kernel 爱好者</small>
        <button id="headerMenu" class="menu"><i class="fa fa-bars"></i></button>
        <nav id="headerNav">
            <ul>
                <li>
                    
                    <a href="/">
                    
                        <i class="fa fa-home"></i>Home
                    </a>
                </li>

                
                    
                    <li>
                        
                        <a href="/archive/">
                        
                            <i class="fa fa-archive"></i>Archives
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/category/">
                        
                            <i class="fa fa-th-list"></i>Categories
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/about/">
                        
                            <i class="fa fa-"></i>About
                        </a>
                    </li>
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </ul>
        </nav>
    </div>
</header>


        <div class="page clearfix" index>
    <div class="left">
        <h1>Welcome to here</h1>
        <small>简单即生活</small>
        <hr>
        <ul>
            
              <li>
                <h2>
                  <a class="post-link" href="/2014/11/27/SetUp/">操作系统启动过程</a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2014-11-27
                    </div>
                    <div class="label-card">
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#OS" title="Category: OS" rel="category">OS</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    <h1 id="do-some-simply-summary-about-process-of-operating-system">Do some Simply summary about process of operating system</h1>

<h2 id="structure-of-floppy-disk">Structure of floppy disk</h2>
<pre>
-----------------
|boot sector|	|		
|___________|   |
| data sector   |
|_______________|

</pre>

<h3 id="structure-of-floppy-disk-boot-sector">Structure of floppy disk’’ boot sector</h3>
<pre>
__________________0x000
|jmp to this code|
|________________|0x003
|disk para table |
|________________|0x02c/0x03e
| part of code   |
|_______________ |0x1f
</pre>

<h1 id="hard-disk">hard disk</h1>
<p>一个硬盘在DOS的文件系统下可分为四个基本分区(primairy partition)，如果数目达不到所需的数目，可以设置扩展分区(Extended partition ),整个硬盘一张分区表，它存放在硬盘的第一个分区里，而每个扩展分区也都有一张分区表，它存放在扩展分区的第一个分区表中,整个硬盘的主引导扇区(MBR)如下图所示：</p>
<pre>
------------------
|	code     |
|________________|
|partition table |
|________________|
| setup signal   |
|________________|

</pre>

<h1 id="boot-loader">boot loader</h1>
<p>在启动的过程中，BIOS会把Boot Loader读入内存，并把控制权交给它，MBR（硬盘启动）或者启动扇区(软盘)的代码就是Boot Loader的一部分，这部分的实现其实是很复杂的，Boot Loader实际上会寻找各自的启动的扇区。</p>


                </div>
                <div class="read-all">
                    <a  href="/2014/11/27/SetUp/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
              <li>
                <h2>
                  <a class="post-link" href="/2014/11/24/Perl/">perl学习笔记(1)</a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2014-11-24
                    </div>
                    <div class="label-card">
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#perl" title="Category: perl" rel="category">perl</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    <h1 id="前言">前言</h1>
<p>我的学习过程中有一个很明显的特点，先知道是什么，最后才知道为什么，不知道这样好不好？</p>

<h1 id="学习perl的网站">学习perl的网站</h1>
<p>http://faq.perl.org/</p>

<h1 id="books">books</h1>
<p>Programming Perl(Camel book)</p>

<p>Perl 5 Pocket Reference</p>

<h1 id="offical-perl-newsgroups-is-complangperl">Offical Perl newsgroups is comp.lang.perl</h1>
<p>其实，perl语言是这么一个流程：在内存中保存他的输出;更新内存;并且打印它</p>

<h1 id="基本语法day01">基本语法day01</h1>
<p>1.scalar : a number,a string,You can act on a scalar value with operators(like additioon or concatenation),You can read scalars from file and devices and write to them as well.</p>

<p>2.在整数常量中，如果数字特别巨大，可以使用 21_323_123_987_365表示</p>

<p>3.Others Nondecimal
0377	#377 octal
0xff	#FF hex,
0b11111111	#also 255 decimal</p>

<p>4.如果在程序中使用utf-8,这样
use utf8;</p>

<p>5.在字符串的使用中，需要注意’ ‘的内容，里面除了“‘”和“"，其余的都代表
他们自己本身，如果想得到一个“\”,那么就使用“\”,为了表示”’“，同样使用“\“转义;
与此对应的是，双引号的使用，你可以想象成c语言中的双引号</p>

<p>6.使用 “.”符号进行链接剪切等操作 For example:</p>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">"hello"</span> <span class="o">.</span> <span class="s">"world"</span> <span class="c1">#same as "helloworld"</span>
<span class="s">"hello"</span> <span class="s">' '</span> <span class="o">.</span> <span class="s">"world"</span> <span class="c1"># same as 'hello world'</span>
<span class="s">'hello world'</span> <span class="o">.</span> <span class="s">"\n"</span> <span class="c1">#same as "hello world\n"</span>
</code></pre></div></div>

<p>7.重复字符串”x”，对，你没看错，就是小写字母x,</p>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">"yubo"</span> <span class="nv">x</span> <span class="mi">3</span>
<span class="s">"yubo"</span> <span class="nv">x</span> <span class="p">(</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p>5 x 4.8 #same as “5555”
最后一个需要说明一下，在操作符 “x”的左边，我们称之为左值，你可以看成源操作数
，符号右边是右值，你可以看成是目的操作数，4.8被自动转换为4.</p>

<p>8.在数字和字符串之间自由转换，这只是取决于你自己用在标量的的操作符，
比如，“+”系统默认为左值和右值为数字，“.”左右值默认为字符串 ，
比如，”12” * “3”就是36,即便在“12yubo34” * 3的结果依旧是36</p>

<h2 id="day02">day02</h2>
<p>1.变量</p>

<p>用$表示，$name,…还可以用于数组</p>

<p>2.变量赋值</p>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$bin</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
<span class="nv">$asd</span> <span class="o">=</span> <span class="nv">$bin</span> <span class="o">*</span><span class="mi">2</span><span class="p">;</span>
</code></pre></div></div>

<p>另外需要注意的是在perl变量中，“ ”与shell中的“ ”一样，
在比较多的变量中，使用${varible}调用其值</p>

<p>3.打印特殊符号，先找到ascii码，然后使用 chr()函数，$alef = chr(0x05D0);
即可。</p>

<p>4.有关perl的运算符的优先级和结合性（结合性依次降低）</p>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">结合性</span>	<span class="err">运算符</span>
<span class="nv">left</span>	<span class="o">-&gt;</span>
	<span class="o">++</span> <span class="o">--</span>
<span class="nv">right</span>	<span class="o">**</span>
<span class="nv">right</span> <span class="o">\</span> <span class="o">!</span> <span class="o">~</span> <span class="o">+</span> <span class="o">-</span><span class="p">(</span><span class="nv">unary</span> <span class="nv">operators</span><span class="p">)</span>
<span class="nv">left</span> 	<span class="o">=~</span> <span class="o">!~</span><span class="p">(?)</span>
<span class="nv">left</span>	<span class="o">*/%</span><span class="nv">x</span>
<span class="nv">left</span>	<span class="o">=-.</span><span class="p">(</span><span class="nv">binary</span> <span class="nv">operations</span><span class="p">)</span>
<span class="nv">left</span>	<span class="o">&lt;&lt;&gt;&gt;</span>
	<span class="o">&lt;</span> <span class="o">&lt;=</span> <span class="o">&gt;</span> <span class="o">&gt;=</span>
	<span class="o">==</span> <span class="o">!=</span> <span class="o">&lt;=&gt;</span>
<span class="nv">left</span> 	<span class="o">&amp;</span>
<span class="nv">left</span>	<span class="o">|</span> <span class="o">^</span>
<span class="nv">left</span>	<span class="o">&amp;&amp;</span>
	<span class="o">..</span> <span class="o">...</span><span class="p">(?)</span>
<span class="nv">right</span>	<span class="p">?:(</span><span class="nv">conditional</span> <span class="nv">operator</span><span class="p">)</span>
<span class="nv">right</span>	<span class="o">=</span> <span class="o">+=</span> <span class="o">-=</span> <span class="o">.=</span><span class="p">(</span><span class="ow">and</span> <span class="nv">similar</span> <span class="nv">assignment</span> <span class="nv">operators</span> <span class="p">)</span>
<span class="nv">left</span>	<span class="p">,</span> <span class="o">=&gt;</span>
<span class="nv">right</span>	<span class="ow">not</span>
<span class="nv">left</span>	<span class="ow">and</span>
<span class="nv">left</span> <span class="ow">or</span> <span class="nv">xor</span>
</code></pre></div></div>

<p>没有必要记住上面的这些东西，如果你找不到你想要的运算顺序，尽管加上括
号即可(parenthses),the same time:</p>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Numeric</span>	<span class="nv">String</span>
<span class="o">==</span>		<span class="ow">eq</span>
<span class="o">!=</span>		<span class="ow">ne</span>
<span class="o">&lt;</span>		<span class="ow">lt</span>
<span class="o">&gt;</span>		<span class="ow">gt</span>
<span class="o">&lt;=</span>		<span class="ow">le</span>
<span class="o">&gt;=</span>		<span class="ow">ge</span>
</code></pre></div></div>

<p>##perl中的bool类型
1.如果返回的值是0为false,其他为true;</p>

<p>2.如果返回的是一个字符串，‘ ’意味着false;其他意味着成功</p>

<p>3.如果还有其他情况，请转化为这两种情况。</p>

<p>1.1,Getting User Input</p>

<p>For example:</p>

<figure class="highlight"><pre><code class="language-perl" data-lang="perl"><span class="nv">$line</span> <span class="o">=</span> <span class="o">&lt;</span><span class="bp">STDIN</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="nv">$line</span> <span class="ow">eq</span> <span class="s">"\n"</span><span class="p">)</span>
	<span class="p">{</span> <span class="k">print</span> <span class="s">"That was just a blank line!\n"</span><span class="p">;}</span>
<span class="k">else</span> <span class="p">{</span> <span class="k">print</span> <span class="s">"The line of input was: $line"</span><span class="p">;}</span></code></pre></figure>

<p>这样就是用户从屏幕标准输入了。</p>

<p>1.2
The chomp Operator
它的作用简单说就是作用于一个变量(输入的值)，把结束符（newline）去掉，
这一步在以后的编程中很有用的，上面的例子，我们一般情况下这样做：
chomp($text = <STDIN>);</STDIN></p>

<p>如果你以这样的方式写出这样的程序，那么就没有换行输出了，因为它自动将换行符去掉了。</p>

<p>1.3
in short,chomp也是一个简单的函数，也有返回值，他的返回值就是清除字符的个数，但是这种用法和我们上面不太一样，是这样</p>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$yubo</span> <span class="o">=</span> <span class="o">&lt;</span><span class="bp">STDIN</span><span class="o">&gt;</span><span class="p">;</span>
<span class="nv">$NAME</span> <span class="o">=</span> <span class="nb">chomp</span> <span class="nv">$yubo</span><span class="p">;</span>
</code></pre></div></div>

<p>输出的结果是1.</p>

<p>1.4 The while control construction
同c语言的一样，很简单的。</p>

<p>1.5使用defined function</p>

<figure class="highlight"><pre><code class="language-perl" data-lang="perl"><span class="nv">$yubo</span> <span class="o">=</span> <span class="o">&lt;</span><span class="bp">STDIN</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span> <span class="nb">defined</span><span class="p">(</span><span class="nv">$yubo</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
<span class="k">print</span> <span class="s">"The input was  $yubo\n"</span><span class="p">;}</span>
<span class="k">else</span> <span class="p">{</span> <span class="k">print</span> <span class="s">"No input available\n"</span><span class="p">;}</span></code></pre></figure>

<h2 id="lists-and-array">lists and array</h2>
<p>1.</p>
<pre>
	$fred[0] = "yubo";
	print $fred[0];
	#perl的数组没有限制，随便用
</pre>
<p>2.列表</p>
<pre>
（1,2,3）
（"yubo",4.5）
 (1..100)
</pre>

<p>2.2 The qw Shortcut</p>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sx">qw( fred yubo hechun wilma dino )</span><span class="c1"># 等同于有双引号的列表</span>
<span class="sx">qw! yahoo\!</span> <span class="nv">google</span> <span class="nv">ask</span> <span class="sr">msn ! #include yahho! as</span> <span class="nv">an</span> <span class="nv">element</span>
</code></pre></div></div>

<p>2.3 List Assignment</p>
<ol>
  <li>($fred, $yubo, $hechun) = (“yubo”, “hechun”, undef)</li>
  <li>($rocks[0], $rocks[1], $rocks[2], $rocks[3]) = qw/yubo hechun mica yubo/;</li>
</ol>

<p>3.在给数组赋值的时候，可以在数组前面加上@,这样就全部赋值了。例如，</p>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">@rocks</span> <span class="o">=</span> <span class="sx">qw/ bedrock slate lava /</span><span class="p">;</span>
<span class="nv">@tiny</span> <span class="o">=</span> <span class="p">();</span><span class="c1"># the empty list</span>
<span class="nv">@giant</span> <span class="o">=</span> <span class="mi">1</span><span class="o">..</span><span class="mf">1e5</span><span class="p">;</span> <span class="c1"># a list with 100000 elements</span>
</code></pre></div></div>

<ol>
  <li>pop and push</li>
</ol>

<p>The pop operator takes the last element off of an array and returns it
@array = 5..9;</p>

<p>$yubo = pop(@array); #$yubo gets 9,@array now has (5,6,7,8)</p>

<p>$barney = pop @array;#barney gets 8,@array now has (5, 6, 7)</p>

<h3 id="push-operator">push operator</h3>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">push</span><span class="p">(</span><span class="nv">@array</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># @array now has (5,6,0)</span>

<span class="nb">push</span> <span class="nv">@array</span><span class="p">,</span><span class="mi">8</span> <span class="c1"># @array now has (5,6,0,8)</span>

<span class="nb">push</span> <span class="nv">@array</span><span class="p">,</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">;</span> <span class="c1"># @array now has those 10 new elements</span>
</code></pre></div></div>

<ol>
  <li>The shift and unshift operators
这shift运算符就是将数组内的元素按从左到右的位置依次取出，
剩下的数组去掉这个元素，取没时用0填充。
    <div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nv">@yubo</span> <span class="o">=</span> <span class="sx">qw# hechun wuhan wangyang #</span><span class="p">;</span>
 <span class="nv">$m</span> <span class="o">=</span> <span class="nb">shift</span> <span class="p">(</span><span class="nv">@yubo</span><span class="p">);</span>
 <span class="nv">$n</span> <span class="o">=</span> <span class="nb">shift</span> <span class="nv">@yubo</span><span class="p">;</span>
<span class="nb">unshift</span> <span class="nv">play</span> <span class="nv">an</span> <span class="nv">oppose</span> <span class="nv">play</span> <span class="nv">vs</span> <span class="nb">shift</span><span class="p">,</span><span class="ow">and</span> <span class="nv">it</span> <span class="nv">used</span> <span class="nv">to</span> <span class="nv">be</span> <span class="nv">filled</span> <span class="nv">with</span> <span class="nv">elements</span><span class="o">.</span>
 <span class="nb">unshift</span><span class="p">(</span><span class="nv">@yubo</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
 <span class="nb">unshift</span> <span class="nv">@yubo</span><span class="p">,</span> <span class="mi">5</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
</ol>

<p>6.分离数组</p>

<p>1.splice就是分离数组的符号，有4个参数，其中</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@yubo = qw(apple, dino, hechun, love);
@removed = splice @yubo, 2; #remove everything after hechun
			 #@removed is qw(hechun,love)
			#@yubo is qw(apple, dino)
</code></pre></div></div>

<p>2.第三个参数就是要删除元素的个数</p>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="nv">@removed</span> <span class="o">=</span> <span class="nb">splice</span> <span class="nv">@yubo</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">#@removed is qw(dino, hechun)</span>
					<span class="c1">#@yubo is qw(apple, love)</span>
</code></pre></div></div>

<p>3.这第四个参数就是你放置要取代的元素，这个数不必和你取出去的相同。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@removed = splice @yubo, 1, 2, qw(wilma);
当然，你可以不用去掉任何元素，只要使第三个参数变0即可。
</code></pre></div></div>

<p>7.@和$
当变量中含有@(list-var)时要注意使用”"转义，还有注意数组的使用。</p>

<p>8.foreach
一个loop的控制变量，一个普遍的用法是用$var读取list的内容，如下：</p>
<pre>
@yubo = qw(yu hechun hehe);
foreach $num (@yubo){
	print "$num\m";
}
</pre>
<p>注意这时的$num不是简单的@yubo的元素的复制，而是实实在在的东西，
你只要改变$num的内容，也能影响@yubo的内容。我们可以使用$_作为foreach的
默认控制变量，打印语句可以直接使用print;</p>

<ol>
  <li>reverse</li>
</ol>

<p>以反序输出内容，如果是单词，按首字母排序。</p>

<ol>
  <li>sort</li>
</ol>

<p>如果是单词，按首字母排序;如果是数字，也是按照首位的大小排序。</p>

<p>以上几个内建函数的对象是list(我觉得)，使用的时候注意，
scalar和list的混用的情况，注意内容与类型的对应要正确。
作者说了，这部分的理解决定了你这一辈子是否使用perl的关键因素，
没有之一。</p>

<h2 id="define">define</h2>
<pre>
sub subroutine-name{

}
</pre>

<h2 id="perl-automatically">perl automatically</h2>
<p>stores the parameter list in the special array named @_,
you can access it to get number of argument and the value of
those arguments. For example,$_[0],$_[1]…</p>

<h2 id="check-number-of-paraments">check number of paraments</h2>
<p>在函数内部使用 <code class="highlighter-rouge">@_</code> 就是参数个数</p>
<pre>
sub max{
	if (@_ != 2){
		print "wrong\n";
	} else {
		print "yes\n";
	}
}
$n = &amp;max(19,23);
</pre>
<p>下面的例子，把函数的规则总结的不错</p>
<pre>
$maxinum = &amp;max(3, 5, 10, 4, 6);
sub max {
	my($max_so_far) = shift @_; # private variable
	foreach (@_){		#look at the remaining arguments
		if ($_ &gt; $max_so_far){
			$max_so_far = $_;
		}
	}
	$max_so_far;
}
print "The maxinum is $maxinum\n";
</pre>

<p>my(var)也叫Lexical(my) Variables,这个变量位于最小的块中，可以是代码块
或者文件。利用关键词my去声明局部变量。</p>
<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">foreach</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">){</span>
	<span class="k">my</span><span class="p">(</span><span class="nv">$square</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$_</span> <span class="o">*</span> <span class="nv">$_</span><span class="p">;</span>
	<span class="k">print</span> <span class="s">"$_  square is $square\n"</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="use-strict">use strict;</h2>
<p>在代码中你只要使用了这条语句，在使用变量的时候就必须先声明后使用，
不然编译器就报告失败.当然对于内建变量是不会报错的，
please use it possiblely.
此时感觉perl真是非同一般，你只要使用了strict，那么程序中的变量就要使用
my去声明。</p>

<h2 id="return-value">return value</h2>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nv">strict</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">@name</span> <span class="o">=</span> <span class="sx">qw(yubo hechun xixi qianqian)</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$result</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">which_element_is</span><span class="p">(</span><span class="s">"xixi"</span><span class="p">,</span><span class="nv">@name</span><span class="p">);</span>
<span class="k">sub </span><span class="nf">which_element_is</span> <span class="p">{</span>
	<span class="k">my</span><span class="p">(</span><span class="nv">$what</span><span class="p">,</span> <span class="nv">@array</span><span class="p">)</span> <span class="o">=</span> <span class="nv">@_</span><span class="p">;</span>
	<span class="k">foreach</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="nv">$#array</span><span class="p">){</span>
		<span class="k">if</span> <span class="p">(</span><span class="nv">$what</span> <span class="ow">eq</span> <span class="nv">$array</span><span class="p">[</span><span class="nv">$_</span><span class="p">]){</span>
			<span class="k">return</span> <span class="nv">$_</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="use-state">use state</h2>
<p>What is state?Please see example follwing:</p>

<figure class="highlight"><pre><code class="language-perl" data-lang="perl"><span class="c1">#!/use/bin/perl</span>
<span class="k">use</span> <span class="nv">strict</span><span class="p">;</span>
<span class="k">sub </span><span class="nf">marine</span> <span class="p">{</span>
	<span class="k">my</span> <span class="nv">$n</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">print</span> <span class="s">"$n\n"</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">foreach</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="nv">marine</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>output:五个1。原因在这里很简单，就是my把变量局限于子函数内，
请不疑惑，尽管我们的$n 在sub marine内，但是，在foreach的调用中，
整体已经过去了，所以只会输出五个1(??)</p>

<h1 id="stardard-input-and-output">Stardard Input And Output</h1>

<h2><STDIN></STDIN></h2>

<p>典型例子</p>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="p">(</span><span class="nb">defined</span><span class="p">(</span><span class="nv">$line</span> <span class="o">=</span> <span class="o">&lt;</span><span class="bp">STDIN</span><span class="o">&gt;</span><span class="p">)){</span>
	<span class="k">print</span> <span class="s">"I saw $line"</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>同样的表达可以是</p>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="p">(</span><span class="o">&lt;</span><span class="bp">STDIN</span><span class="o">&gt;</span><span class="p">){</span>
	<span class="k">print</span> <span class="s">"I saw $_"</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">foreach</span> <span class="p">(</span><span class="o">&lt;</span><span class="bp">STDIN</span><span class="o">&gt;</span><span class="p">){</span>
	<span class="k">print</span> <span class="s">"I saw $_"</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1"># Ctrl + D</span>
</code></pre></div></div>

<h2 id="-1">&lt;&gt;</h2>
<p>Reading variables from <strong>input</strong>,</p>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="p">(</span><span class="o">&lt;&gt;</span><span class="p">)</span> <span class="p">{</span>
	<span class="nv">chmop</span><span class="p">;</span>
	<span class="k">print</span> <span class="s">"It was $_ that i saw"</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="filehandle">Filehandle</h2>
<p>名字最好使用大写字母，这样有好几个优势。</p>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">open</span> <span class="nv">CONFIG</span><span class="p">,</span> <span class="s">'dino'</span><span class="p">;</span> <span class="c1"># dino is filename</span>
<span class="nb">open</span> <span class="nv">config</span><span class="p">,</span> <span class="s">'&lt;dino'</span><span class="p">;</span>
<span class="nb">open</span> <span class="nv">BEDROCK</span><span class="err">，</span><span class="s">'&gt;fred'</span>
</code></pre></div></div>

<p>you can use a “three-argument” open:</p>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="nb">open</span> <span class="nv">CONFIG</span><span class="p">,</span> <span class="s">'&lt;'</span><span class="p">,</span> <span class="s">'dino'</span><span class="p">;</span>
	<span class="nb">open</span> <span class="nv">BEDROCK</span><span class="p">,</span> <span class="s">'&gt;'</span><span class="p">,</span> <span class="s">'$file_name'</span><span class="p">;</span>
	<span class="nb">open</span> <span class="nv">CONFIG</span><span class="err">，</span><span class="s">'&lt;:encoding(UTF-8)'</span><span class="p">,</span> <span class="s">'dino'</span><span class="p">;</span>
	<span class="nb">open</span> <span class="nv">LOG</span><span class="p">,</span> <span class="s">'&gt;&gt;:encoding(UTF-8)'</span><span class="p">,</span> <span class="o">&amp;</span><span class="nv">logfile_name</span><span class="p">();</span>
</code></pre></div></div>

<h2 id="die-statement">die statement</h2>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="nb">open</span> <span class="nv">LOG</span><span class="p">,</span> <span class="s">'&gt;&gt;'</span><span class="p">,</span> <span class="s">'logfile'</span><span class="p">)</span> <span class="p">{</span>
		<span class="nb">die</span> <span class="s">"Cannot create logfile: $!"</span>
	<span class="p">}</span>
</code></pre></div></div>

<p>这个判断语句就是判断是否能创建logfile文件，不能的话返回一个数值，
这个值就是不能的含义，在这里，可以把die和pirnt联系起来，共同报错。</p>

<h2 id="filehandle-补充">filehandle 补充</h2>
<p>Recently i thought sth deeply,English is my shortcut to learn
linux kernel and others, and lack of indpendent of thinking.</p>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">use</span> <span class="nv">strict</span><span class="p">;</span>
	<span class="k">use</span> <span class="nv">warnings</span><span class="p">;</span>

	<span class="nb">open</span> <span class="p">(</span><span class="k">my</span> <span class="nv">$yubo</span><span class="p">,</span> <span class="s">'&gt;'</span><span class="p">,</span> <span class="s">'log'</span><span class="p">);</span>
	<span class="k">print</span> <span class="nv">$yubo</span> <span class="s">"My first report generated by perl\n"</span><span class="p">;</span>
	<span class="nb">close</span> <span class="nv">$yubo</span><span class="p">;</span>
	<span class="k">print</span> <span class="s">"done\n"</span><span class="p">;</span>
</code></pre></div></div>

<p>这就是一个典型的文件句柄。open函数可以传入3个参数。</p>

<p>第一个， $yubo,是在 open()调用中定义的标量，第二个参数是读写文件的方式，第三个是文件路径。</p>

<p>文件的内容仍在磁盘上，并不在$yubo变量中，可能你往句柄中写入内容，
东西就会在文件中保存。</p>

<p>这个$yubo就可以类推c语言中的文件描述符（fd），有意思吧！</p>

<h3 id="open-or-die">open or die</h3>

<blockquote>
  <p>open(my $yubo, ‘&gt;’, ‘no_exist/file’) or die;</p>
</blockquote>

<p>下面这种用法结合前面几种的方法</p>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">my</span> <span class="nv">$filename</span> <span class="o">=</span> <span class="s">'No_exist_file'</span><span class="p">;</span>
	<span class="nb">open</span><span class="p">(</span><span class="k">my</span> <span class="nv">$yubo</span><span class="p">,</span> <span class="s">'&gt;'</span><span class="p">,</span> <span class="nv">$filename</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">die</span> <span class="s">"could not open $filename $!"</span><span class="p">;</span>
	<span class="c1"># return error information</span>
</code></pre></div></div>

<h3 id="argv">@ARGV</h3>
<p>当时偷懒了，只是简单的记录下来，并不知道什么意思。现在再重新整理整理。
顾名思义，@ARGV就是一个参数，这个参数接受外部变量，这里，这个变量就是某个路径上的文件，将该文件上的内容输出。</p>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="nv">@ARGV</span> <span class="o">=</span> <span class="p">(</span><span class="s">"file1"</span><span class="p">,</span><span class="s">"file2"</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="nv">$line</span> <span class="o">=</span> <span class="o">&lt;&gt;</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">print</span> <span class="s">"$line\n"</span><span class="p">;</span>
	<span class="p">}</span>
</code></pre></div></div>

<p>上面的东西，一看就是菜鸟写的，应该简单一点是这样</p>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="nv">@ARGV</span> <span class="o">=</span> <span class="p">(</span><span class="s">"file1"</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">&lt;&gt;</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">print</span> <span class="s">"$_"</span><span class="p">;</span>
	<span class="p">}</span>
</code></pre></div></div>

<h2 id="hash">hash</h2>
<p>For example:</p>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="nv">$family_name</span><span class="p">{</span><span class="s">'yubo'</span><span class="p">}</span> <span class="o">=</span> <span class="s">'flintstone'</span><span class="p">;</span>
	<span class="nv">$family_name</span><span class="p">{</span><span class="s">'hechun'</span><span class="p">}</span> <span class="o">=</span> <span class="s">'love'</span><span class="p">;</span>
	<span class="k">foreach</span> <span class="k">my</span> <span class="nv">$person</span> <span class="p">(</span><span class="sx">qw &lt;yubo </span><span class="nv">hechun</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">print</span> <span class="s">"I've heard of $person $family_name{$person}.\n"</span><span class="p">;</span>
	<span class="p">}</span>
</code></pre></div></div>

<h3 id="hash-assignment">Hash Assignment</h3>
<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">my</span> <span class="o">%</span><span class="nv">new_hash</span> <span class="o">=</span> <span class="o">%</span><span class="nv">old_hash</span><span class="p">;</span>
	<span class="k">my</span> <span class="o">%</span><span class="nv">last_name</span> <span class="o">=</span> <span class="p">(</span>
		<span class="s">'Yu'</span> <span class="o">=&gt;</span> <span class="s">'bo'</span><span class="p">,</span>
		<span class="s">'He'</span> <span class="o">=&gt;</span> <span class="s">'chun'</span><span class="p">,</span>
	<span class="p">);</span>

	<span class="k">foreach</span> <span class="k">my</span> <span class="nv">$first</span> <span class="p">(</span><span class="sx">qw &lt;Yu </span><span class="nv">He</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">print</span> <span class="s">"$first in @last_name{$first}.\n"</span><span class="p">;</span>
	<span class="p">}</span>
</code></pre></div></div>

<p>上面的hash赋值完后还可以使用 $hash{“d”} = 1; 的方式解决。
还有一种方式可以赋值：</p>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">my</span> <span class="o">%</span><span class="nv">last_name</span><span class="p">;</span>
	<span class="nv">$last_name</span><span class="p">{</span><span class="s">"fred"</span><span class="p">}</span> <span class="o">=</span> <span class="s">"hehe"</span><span class="p">;</span>
	<span class="nv">$last_name</span><span class="p">{</span><span class="s">"yubo"</span><span class="p">}</span> <span class="o">=</span> <span class="s">"bo"</span><span class="p">;</span>
	<span class="nv">$last_name</span><span class="p">{</span><span class="s">"he"</span><span class="p">}</span> <span class="o">=</span> <span class="s">"chun"</span><span class="p">;</span>
</code></pre></div></div>
<p>注意，赋值的时候使用%，使用的时候却是$</p>

<p>下面这句话改变了 key 和 value 的位置。</p>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">my</span> <span class="o">%</span><span class="nv">inverse_hash</span> <span class="o">=</span> <span class="nb">reverse</span> <span class="o">%</span><span class="nv">any_hash</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="hash-functions-keys-and-values">Hash functions: keys and values</h3>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">my</span> <span class="o">%</span><span class="nv">hash</span> <span class="o">=</span> <span class="p">(</span><span class="s">'a'</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s">'b'</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="s">'c'</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="p">);</span>
	<span class="k">my</span> <span class="nv">@k</span> <span class="o">=</span> <span class="nb">keys</span> <span class="o">%</span><span class="nv">hash</span><span class="p">;</span>
	<span class="k">my</span> <span class="nv">@v</span> <span class="o">=</span> <span class="nb">values</span> <span class="o">%</span><span class="nv">hash</span><span class="p">;</span>
	<span class="k">foreach</span> <span class="p">(</span><span class="nv">@k</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">print</span> <span class="s">"$_\n"</span><span class="p">;</span>
	<span class="p">}</span>
</code></pre></div></div>
<p>这样就会打印hash的key，但是有一点请注意，perl不保证输出的顺序，
也就是你最好不要期望得到你想要的顺序。又但是，keys 和 values函数
可以保证此时的值相对应，例如，上面的例子@k会打印出c b a,那么打印
的@v一定是3 1 2</p>

<p>There is another function:</p>
<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">my</span> <span class="nv">$count</span> <span class="o">=</span> <span class="nb">keys</span> <span class="o">%</span><span class="nv">hash</span><span class="p">;</span>
</code></pre></div></div>
<p>$count的值就是hash函数中的对数。</p>

<h3 id="hash-function-each">Hash function: each</h3>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">while</span> <span class="p">(</span> <span class="p">(</span><span class="nv">$key</span><span class="p">,</span> <span class="nv">$value</span><span class="p">)</span> <span class="o">=</span> <span class="nb">each</span> <span class="o">%</span><span class="nv">hash</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">print</span> <span class="s">"$key =&gt; $value\n"</span><span class="p">;</span>
	<span class="p">}</span>
</code></pre></div></div>

<p>After sorted hash</p>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">foreach</span> <span class="nv">$key</span> <span class="p">(</span><span class="nb">sort</span> <span class="nb">keys</span> <span class="o">%</span><span class="nv">hash</span><span class="p">)</span> <span class="p">{</span>
		<span class="nv">$value</span> <span class="o">=</span> <span class="nv">$hash</span><span class="p">{</span><span class="nv">$key</span><span class="p">};</span>
		<span class="k">print</span> <span class="s">"$key =&gt; $value\n"</span><span class="p">;</span>
	<span class="p">}</span>
</code></pre></div></div>

<p>The exists Function,to see whether a key exists in the hash, use the exists function,if true</p>

<p>以上面的代码为例：</p>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">if</span> <span class="p">(</span><span class="nb">exists</span> <span class="nv">$hash</span><span class="p">{</span><span class="s">"a"</span><span class="p">})</span> <span class="p">{</span>
		<span class="k">print</span> <span class="s">"Hey, there exist\n"</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nb">exists</span> <span class="nv">$hash</span><span class="p">{</span><span class="s">"d"</span><span class="p">})</span> <span class="p">{</span>
		<span class="k">print</span> <span class="s">"NO exist!\n"</span><span class="p">;</span>
	<span class="p">}</span>
</code></pre></div></div>

<p>不知道我的思路是否有问题，$hash,@hash,%hash三者之间有着某种联系,
虽说hash是用来定义的，但它仅仅是定义吗？在其他的外部调用中，我们
反而使用的是$hash{“”},在当时学习@hash和$hash也有同样的问题。</p>

<h3 id="the-env-hash">The %ENV hash</h3>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	print "PATH is $ENV{path}\n";
</code></pre></div></div>
<h3 id="exercises">Exercises</h3>

<p>write a perl file, output the times of that have read from terminal.
For example, input “yubo,hechun,yubo,hechun” output the
numbers”yubo 2…hechun 2”</p>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">my</span><span class="p">(</span><span class="nv">@words</span><span class="p">,</span> <span class="o">%</span><span class="nv">count</span><span class="p">,</span> <span class="nv">$word</span><span class="p">);</span> <span class="c1"># declare</span>
	<span class="nb">chomp</span><span class="p">(</span><span class="nv">@words</span> <span class="o">=</span> <span class="o">&lt;</span><span class="bp">STDIN</span><span class="o">&gt;</span><span class="p">);</span> <span class="c1"># input</span>

	<span class="k">foreach</span> <span class="nv">$word</span> <span class="p">(</span><span class="nv">@words</span><span class="p">)</span> <span class="p">{</span>
		<span class="nv">$count</span><span class="p">{</span><span class="nv">$word</span><span class="p">}</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">foreach</span> <span class="nv">$word</span> <span class="p">(</span><span class="nb">keys</span> <span class="o">%</span><span class="nv">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">print</span> <span class="s">"$word was seen $count{$word} time . \n"</span><span class="p">;</span>
	<span class="p">}</span>
</code></pre></div></div>

<p>自己从这个程序中稍微理解了hash的原理,其中最后一个比较有意思,
在count hash中$word作为keys,so the value is $count{$word}.</p>

<p>下面的例子与上面的很类似</p>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="nv">$longest</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">foreach</span> <span class="k">my</span> <span class="nv">$key</span> <span class="p">(</span><span class="nb">keys</span> <span class="o">%</span><span class="nv">ENV</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">my</span> <span class="nv">$key_long</span> <span class="o">=</span> <span class="nb">length</span><span class="p">(</span><span class="nv">$key</span><span class="p">);</span>
		<span class="nv">$longest</span> <span class="o">=</span> <span class="nv">$key_long</span> <span class="k">if</span> <span class="nv">$key_long</span> <span class="o">&gt;</span> <span class="nv">$longest</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">foreach</span> <span class="k">my</span> <span class="nv">$key</span> <span class="p">(</span><span class="nb">sort</span> <span class="nb">keys</span> <span class="o">%</span><span class="nv">ENV</span><span class="p">)</span> <span class="p">{</span>
		<span class="nb">printf</span> <span class="s">"%-s{longest} %s \n.$key, $ENV{$key}"</span><span class="p">;</span>
	<span class="p">}</span>

</code></pre></div></div>


                </div>
                <div class="read-all">
                    <a  href="/2014/11/24/Perl/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
              <li>
                <h2>
                  <a class="post-link" href="/2014/11/24/LinuxDeveicsDriver2/">LDD读书笔记(2)</a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2014-11-24
                    </div>
                    <div class="label-card">
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#book" title="Category: book" rel="category">book</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    <p>#Debugging Techniques
无论什么样的原因你都应该自己编译内核,在__kernel hacking__ menu 下,你最好开启以下选项.
###CONFIG_DEBUG_KERNEL
the option just makes other debugging options available.
###CONFIG_DEBUG_SLAB
这对于内核内存分配函数非常关键,	它可以推断溢出的内存的数量以及未初始化的错误,每一个被分配的内存的字节在处理之前是0xa5,当被释放后是0x6b…
###CONFIG_DEBUG_PAGEALLOC
Full pages are removed from the kernel address space,the option can slow it,also point out certain kinds of memory corruption errors
###CONFIG_DEBUG_SPINLOCK
It catches uninitialized spinlock and other errors(such as unlocking a lock twice)</p>

<p>###CONFIG_DEBUG_SPINLOCK_SLEEP
开启这个选项,如果你呼叫一个潜在(可能不是)的sleep函数,它就会发出警告.
###CONFIG_INIT_DEBUG
Items marked with <strong>init(__initdata)在系统初始化完成后或模块加载完毕后被丢弃.
###CONFIG_DEBUG_INFO
The information debugging with __gdb</strong>,You also want to enable CONFIG_FRAME_POINTER.
###CONFIG_MAGIC_SYSRQ</p>

<p>###CONFIG_DEBUG_STACKOVERFLOW AND CONFIG_DEBUG_STACK_USAGE
These options can help trace down kernel stack overflows.
###CONFIG_KALLSYMS
This option (under “General setup/Stardsrd features”) causes kernel symbol information to be built into the kernel.
###CONFIG_IKCONFIG AND CONFIG_IKCONFIG_PROC
These options (under “General setup”) cause the full kernel configuration state and to be made available via /proc.
###CONFIG_ACPI_DEBUG</p>

<p>###CONFIG_DEBUG_DRIVER
It is useful to trace down the low-level support code.
###CONFIG_SCSI_CONSTANTS
The item (under “Device drivers/SCSI device support”)
###CONFIG_INPUT_EVBUG
The item (“Device drivers/Input device suuport”) including security implications and however: it logs everything you type.
###CONFIG_PROFILING</p>

<p>#Debugging by Printing
The variable console_loglevel is initialized to DEFAULT_CONSOLE_LOGLEVEL AND can be modified through the sys_syslog system call,P95 这一段没看明白.
###Redirecting Console Messages
同样没有看懂
###How Messages Get Logged
The printk function writes messages into a circular buffer that is __LOG_BUF_LEN bytes long (from 4 KB to 1 MB) while configuring the kernel.</p>

<p>###系统日志那块很麻烦
###Rate Limit
如果你的设备有错误,但是你只是想打印一次的错误,那可以考虑</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int printk_ratelimit(void);
</code></pre></div></div>

<p>如果这个函数返回一个非0的数,那么继续打印消息,典型的应用是</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (printk_ratelimit())
	printk(KERN_NOTICE "The printer is still on fire\n");
</code></pre></div></div>

<p>这个函数的行为可以通过 /proc/sys/kernel/printk_ratelimit改变.
###print device numbers
Defined in &lt;linux/kdev_t.h&gt;</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int print_dev_t(char *buffer, dev_t dev);
char *format_dev_t(char *buffer, dev_t dev);
</code></pre></div></div>

<p>这一块学的真垃圾.</p>

<p>###Using the /proc/ Filesystem</p>

<p>这个目录下的文件是内核把硬件信息告诉外界./proc是很重要在linux system中,许多命令例如ps,top,uptime严重依赖这个目录.你的驱动也可以使用这个东西,并且是动态的.
我们最好使用 sysfs去调试信息.</p>

<p>&lt;linux/proc_fs.h&gt;是所有工作在/proc的模块的头文件,当有进程访问/proc下的文件,内核首先分配一页内存(4096 kb),此内存用来将数据发往用户空间,</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int (*read_proc)(char *page, char **start, off_t offset, int count,
		int *eof, void *data)
</code></pre></div></div>

<p>其中的offset和count同read方法的一致,其他的就可以按照字面上的理解.这个函数的参数需要注意.</p>

<p>下面是一个简单的例子:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">	<span class="kt">int</span> <span class="nf">scull_read_procmen</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">start</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">offset</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">eof</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">count</span> <span class="o">-</span><span class="mi">80</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">scull_nr_devs</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="n">limit</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">scull_dev</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">scull_devices</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">struct</span> <span class="n">scull_qset</span> <span class="o">*</span><span class="n">qs</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">down_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span><span class="s">"</span><span class="se">\n</span><span class="s">Device %i: qset %i, q %i, sz %li</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
					<span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">qset</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">quantum</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(;</span><span class="n">qs</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="n">limit</span><span class="p">;</span> <span class="n">qs</span> <span class="o">=</span> <span class="n">qs</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="s">" item at %p, qset at %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
						<span class="n">qs</span><span class="p">,</span> <span class="n">qs</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span><span class="cm">/*dump only last item*/</span>
					<span class="k">for</span> <span class="p">(</span><span class="n">qs</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
						<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span>
								<span class="s">"	% 4i:%8p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
								<span class="n">j</span><span class="p">,</span> <span class="n">qs</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
			<span class="p">}</span>
		<span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scull_devices</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sem</span><span class="p">);</span>

		<span class="p">}</span>
		<span class="o">*</span><span class="n">eof</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
	
	<span class="p">}</span></code></pre></figure>

<p>##kdb内核调试器</p>

<p>1.在编译内核时，首先将支持kdb的选项打开，在 Linux hacking » KGDB</p>

<p>2.在控制台下，按下 Pause Break 键启动调试，当内核发生oops，或者到达一个断点时也会开启调试。</p>

<p>3.具体用到的时候再说
##并发和竞争</p>

<p>1.当一个linux process reaches a point where it cannot make any further process it goes to sleep (or “block”)</p>

<p>2.使用锁机制容易造成“sleep”，所以使用信号量来避免，在linux中，有一对函数叫做P，V。在进入临界区前，首先呼叫p，并且将value-1,V 释放这个信号量。当这两个函数出现意外时，需要等待…</p>

<p>3.实现</p>

<p>为了使用semaphore,需要包括&lt;asm/semaphore&gt;</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct semaphore;

void sem_init(struct semaphore *sem, int val); 
// val is the inital value to assign to a semaphore.
</code></pre></div></div>

<p>还可以使用MACROS</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DECLARE_MUTEX(NAME); // ==&gt;&gt; 1

DECLARE_MUTEX_LOCKED(NAME); // ==&gt;&gt; 0
</code></pre></div></div>

<p>如果在运行时进行初始化，可以使用以下两种方法</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void init_MUTEX(struct semaphore *sem);
void init_MUTEX_LOCKED(struct semaphore *sem);
</code></pre></div></div>

<p>使用：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void down (struct semaphore *sem);
void down_interruptible(struct semaphore *sem); 
//产生不可杀的进程(D state in PS command)
int down_trylock(struct semaphore *sem);
//立即返回nonzero

void up(struct semaphore *sem);
</code></pre></div></div>

<p>使用信号量通过down获得，也就是说在你的目标代码中使用上述的的down xx（），可以获得这个信号量;当你离开这个临界区时，通过up()释放。</p>

<p>首先我们在设备文件中设置</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct semaphore sem;
init_MUTEX(&amp;scull_devices[i].sem);
//一定要在设备分配之前使用

up(&amp;dev-&gt;sem);
//must clean up
</code></pre></div></div>

<p>###Read/write semaphore
如果只是仅仅访问收保护的临界区，我们可以使用rwsem(“reader/writer semaphore”), it comes from &lt;linux/rwsem.h&gt;.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void down_read(struct rw_semaphore *sem);
int down_read_trylock(struct rw_semaphore * sem);
void up_read(struct rw_semaphore *sem);
</code></pre></div></div>

<p>down_read只是使用可读的权限使用被保护的数据，还可以是并发的。它可以把呼叫程序处于一种不可中断的睡眠。down_read_trylock如果成功的话返回非0,不成功返回0,这一点与其它的内核函数一样。一个 rwsem使用down_read到的，必须使用up_read释放。</p>

<p>for writer:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void down_write(struct rw_semaphore *sem);
int down_write_trylock(struct rw_semaphore *sem);
void up_write(struct rw_semaphore *sem);
void downgrade_write(struct rw_semaphore *sem);
</code></pre></div></div>

<p>综合rwsem的表现，我们拥有rwsem的时间不能过长，否则会出问题.
###completion
即便使用信号量我们也不能保障临界区的安全使用，in the 2.4.7 kernel,we can use completion that allow one thread to tell another that job is done. &lt;linux/completion.h&gt;</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DECLARE_COMPLETION(my_completion);
</code></pre></div></div>

<p>如果动态的使用，则</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct completion my_completion;
/*...*/
init_completion(&amp;my_completion); wait.

void wait_for_completion(strcut completion *c);
</code></pre></div></div>

<p>这个函数是不可中断的，如果使用后不及时释放，会产生不可杀的进程.</p>


                </div>
                <div class="read-all">
                    <a  href="/2014/11/24/LinuxDeveicsDriver2/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
              <li>
                <h2>
                  <a class="post-link" href="/2014/11/24/LinuxDeveicsDriver/">LDD读书笔记(1-4)</a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2014-11-24
                    </div>
                    <div class="label-card">
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#book" title="Category: book" rel="category">book</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    <p>1.insmod 是系统调用 kernel/module.c，The function sys_init_module allocates kernel memory(how)=&gt;（ The memory is allocated with vmalloc function）,系统调用函数把模块复制到内存区，通过内核符号表解决内核引用的问题，并且呼叫模块初始化函数使一切准备就绪。</p>

<p>2.在内核源代码中，使用前缀sys_ 就是系统调用。</p>

<p>3.modprobe 命令比insmod命令高级一点，它会自动解决模块引用不成功的问题。</p>

<p>4.如果模块正在被使用，清除模块的任务将会失败，或者这个模块已经被定义为不可清除</p>

<p>5.lsmod 将会列出目前正在内核被加载的模块还有例如其他模块正在使用一个特殊的模块，他是通过读 /proc/modules虚拟文件实现的。当前加载的模块也可以在虚拟系统文件 /sys/module读取。</p>

<p>6.在装载模块时，在链接的过程中会寻找一个目标文件 vermagic.o（不过，在debian中我没有找到这个文件）和当前的系统配置相对照，还有 vmlinux是做什么用的？</p>

<ol>
  <li>系统文件日志
/var/log/messages,
终于印证了我的设想，如果我想编译一个模块但不是现在源码树的内核，应该重新指定KERNELDIR，测试一下。</li>
</ol>

<p>8.当你写的驱动需要在不同版本的linux上运行时，你这时就需要充分利用macros和#ifdef结构体了，类似大量的定义在这个文件linux/veersion.h中，这个头文件自动包括linux/module.h</p>

<p>UTS_RELEASE
这个宏定义了一个描述这个代码树的版本的字符串，例如”2.6.10”</p>

<p>LINUX_VERSION_CODE
定义了一个代表内核版本的二进制文件，一个字节代表版本的一部分，如，2.6.10是132618(0x020610)</p>

<p>KERNEL_VERSION(major,minor,release)
KERNEL_VERSION(2.6.10)==&gt;132618,</p>

<p>not clutter driver (填充)</p>

<p>9.解决 platform dependency</p>

<p>The best way is to release your driver under a GPL-compatible license and contribute it to the mainline kernel,distributing your driver in source form and a set of scripts to compile it on the user’s platform</p>

<h2 id="2014-11-23">2014-11-23</h2>

<p>msdos relies on symbols exported by the fat module, and each input USB device stacks on the usbcore and input modules.
有意识的去使用modprobe，这一句命令就可以代替很多insmod命令，
如果你写的模块希望被其他模块所使用，最好加入以下两句话
EXPORT_SYMBOL(name);
EXPORT_SYMBOL_GPL(name);
具体的请参看&lt;linux/module.h&gt;吧，在模块中有一个“ELF”部分，在那里导入了有关符号表的东西。
MODULE_AUTHOR();
MODULE_VERSION();
MODULE_ALIAS();
MODULE_DEVICE_TABLE();</p>
<ol>
  <li>初始化
static int __int initialization_function(void)
{
/<em>code</em>/
}
module_init(initialization_function);
这初始化函数应该被定义为static,__init提示内核当模块被加载后可以释放掉空间…这还有相似的标签(__initdata) for data used only during initialization,只是必须牢记，这些函数只是能在初始化的时候使用，其他时候不再使用，我们在没有配置热插拔选项的内核中可能会遇到与上面类似的tags：devinit and devinitdata</li>
</ol>

<p>module__init 是强制性， 这个宏增加了一个的段对于模块的目标代码在初始化函数，没有这个定义，初始化函数是从来不会调用的。</p>

<p>模块可以注册不同的设备，对于不同的设备，这有一个特别的函数完成注册，传递给内核注册函数的参数一般是指向新设备的数据结构和这个注册设备的名字，这个数据结构经常包含指向模块函数的指针，这也是在模块体内部的函数得到调用的方法。</p>

<p>以下这些东西：串口，miscellaneous(杂项)设备，系统文件，/proc 文件，可执行的域名，line discipline（线性规划），这些文件不是直接与硬件打交道，但保持这软件抽象域，这些东西是可以被注册的。</p>

<p>这还有其他设备的插件也可以被注册，绝大多数用register_前缀。</p>

<p>11.清除函数
a function marked __exit can be called only at module unload ro system shutdown time.any other use is an error.
and it (__exit)is vital for cleanup function.</p>

<p>In the linux kernel, err codes are negative numbers defined in the &lt;linux/errno.h&gt;</p>

<p>p52–p53的代码没有看明白。</p>

<h3 id="模块装载竞争">模块装载竞争</h3>
<p>1.你必须准备好只要你的代码完成它的第一步注册就有可能被调用，把你模块需要的设备准备好以后再去注册你的初始化函数。</p>

<p>2.避免把初始化函数失败。</p>

<p>###.模块参数
IDE can allow user control of DMA operations.
hardware need to know I/O ports and I/O memory address.
参数值可以被赋值在使用命令 insmod 或者 modprobe的时候，使用module_param macro,which is defined in <moduleparam.h>中
它带来三个参数：变量，类型，特权，例如下面的</moduleparam.h></p>

<pre>
static char *whom = "world";
static int howmany = 1;
module_param(howmany, int, S_IRUGO);
module_param(whom, charp, S_IRUGO);
</pre>

<p>使用命令
insmod hellop howmany=10 who=”Mom”;(有问题)</p>

<p>数组参数使用module_param_array(name,type,num,perm);
the perm was defined in &lt;linux/stat.h&gt;,</p>

<h2 id="11-27">11-27</h2>
<p>第一个字符设备驱动</p>

<p>在dev_t中，12位的主设备号，20位的次设备号，你的代码应该充分利用在 &lt;linux/kdev_t&gt;的宏，为了去获得主设备号和次设备号dev_t，使用如下命令：</p>

<pre>
MAJOR(dev_t dev);
MINOR(dev_t dev);
</pre>

<p>then,use <strong>MKDEV(int major, int minor)</strong>;</p>

<h3 id="字符设备">字符设备</h3>
<p>为一个字符串设备获得设备号的函数是</p>

<pre>
register_chrdev_region(dev_t first,unsigned int count,
			char *name)
</pre>

<p>first 是你申请的开始设备号的范围，这经常从0开始，count是你申请的设备的总数
name必须和你的number相对应，而且这个名字就在/proc/devices中显示，另外，这个/proc/目录是个虚拟目录，它时刻在读取计算机的各个硬件cpu、io、模块等信息，要注意利用啊。
这个函数如果正确执行，会返回一个0,否则就返回一个负数,现在很多人努力使用这个函数，</p>

<pre>
int alloc_chrdev_region(dev_t *dev, unsigned int firstminor,
			unsigned int count, char *name)
</pre>

<p>记住，申请完设备后一定要记得释放，驱动程序应该始终使用alloc_chrdev_region.</p>

<pre>
void unsigned_chrdev_region(dev_t first,unsigned int count)
</pre>

<h2 id="非重点disgression">非重点(disgression)</h2>
<p>Major devices numbers 静态分配的多些，这些设备清单在内核的Documentayion/devices.txt,如果你的设备不工作，那么试试以下两种方法: 1.使用未使用的静态主设备号;2.使用动态分配的方法,in other word,我们应该更多的使用alloc_chrdev_region而不是register_chrdev_region.</p>

<h3 id="主设备号">主设备号</h3>
<p>是关于驱动程序的，例如 /dev/null,/dev/zero 的主设备号是1,虚拟控制台和串口终端是4,VCSL和VCSL设备是7.</p>

<h3 id="次设备号">次设备号</h3>
<p>由内核使用，用于正确确定设备文件所指的设备，可以通过设备号获得一个指向内核设备的直接指针。</p>

<h3 id="三个重要的数据结构">三个重要的数据结构</h3>
<p>file_operations structure :</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">file_operations</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span><span class="c1">//&lt;linux/module.h&gt; =&gt; THIS_MODULE</span>
	<span class="n">loff_t</span> <span class="p">(</span><span class="o">*</span><span class="n">llseek</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="c1">//loff_t is long long							//via __kernel_loff_t;</span>
<span class="c1">//change current read/write						//position.</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">);</span>
	<span class="cm">/* ssize_t viaing  __kernel_ssize_t is defined long,
	   通常这个函数返回从设备读来的字节数，
	   如果是NULL,则会返回 -EINVAL("Invalid arguments")
	 */</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">aio_read</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="p">,</span><span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">);</span>
		<span class="c1">//异步读</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/*返回一个非负的整数(long long ),表示已经向设备发送了多少字节，if NULL, return -EINVAL;
	 */</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">aio_write</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">);</span> <span class="c1">//异步写方式</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">readdir</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="n">filldir_t</span><span class="p">);</span>
	<span class="cm">/*它是被用来读管道，并且仅仅用于文件系统，对于设备文件，仅仅使用NULL*/</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">poll</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">poll_table_struct</span> <span class="o">*</span><span class="p">);</span>
	<span class="cm">/*这个方法被用于三个系统调用，poll,epoll,select,询问一个读或写的文件描述符是否堵塞，if a driver
	  leaves its poll method NULL,这个设备被认为可读可写
	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ioctl</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="cm">/*这ioctl系统调用提供了一种方式去实现设备的特殊命令，例如格式化软驱磁道，如果不存在
	  这样的ioctl方法，系统将会返回-ENOTTY("NO such ioctl for device")
	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">mmap</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">);</span>
	<span class="cm">/*
	   mmap 被用来映射设备内存到进程地址空间，如果这里是NULL，那么返回 _ENODEV
	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">open</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">);</span><span class="c1">//first operation,but...</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">flush</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="o">*</span><span class="p">);</span>
	<span class="cm">/*目前，很少使用flush，如果它为NULL,kernel will ignore user application request.
	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">release</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">);</span>
	<span class="cm">/*激活file数据结构*/</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fsync</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="cm">/*This method is the back end of the fsync system call,which a user calls to flush any
	  pending data,if this is NULL, return -EINVAL*/</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">aio_fsync</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span><span class="c1">//异步</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fasync</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="cm">/*这个方法被用来通知设备去改变它的FASYNC的标志，这是关于一个异步的问题*/</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">lock</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="p">,</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="p">);</span>
	<span class="cm">/*loch 方法被用来实现文件锁，locking对于日常文件很重要，但是对于设备驱动
	  却几乎没有用过*/</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">readv</span><span class="p">)(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="p">,</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span><span class="n">loff_t</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">writev</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span><span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="p">,</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span><span class="n">loff_t</span> <span class="o">*</span><span class="p">);</span>
	<span class="cm">/*实现扫描/采集 读或写 操作，if is NULL，被read和write代替*/</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">sendfile</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">,</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">read_actor_t</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="c1">//实现 sendfile系统调用，从一个文件描述符移动数据到另一个。=&gt; NULL</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">sendpage</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="p">;</span>
	<span class="cm">/*被内核用来发送数据一次一页同上面一样*/</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">get_unmapped_area</span><span class="p">)(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="cm">/*NULL？？*/</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">check_flags</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>
	<span class="cm">/*检查传递给fcntl的标志*/</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">dir_notify</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="cm">/*当一个进程使用fcntl去要求目录改变，仅用来用于文件系统*/</span>


<span class="p">};</span></code></pre></figure>

<p>这个scull设备驱动被初始化如下：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct file_operations scull_fops = {
	.owner = THIS_MODULE,
	.llseek = scull_llseek,
	.read = scull_read,
	.write = scull_write,
	.ioctl = scull_ioptl,
	.open = scull_open,
	.release = scull_release,
};
</code></pre></div></div>

<p>hints:</p>

<p>对于结构体</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct a {
	int a;
	int b;
}
</code></pre></div></div>

<p>有以下几种初始化方式：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct a a1 = {
	.a = 1,
	.b = 2,
};
</code></pre></div></div>

<p>或者</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct a a2 = {
	a:1,
	b:2,
};
</code></pre></div></div>

<p>or</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct a a3 = {
	1,2
};
</code></pre></div></div>

<p>内核喜欢用第一种方式，使用第一种和第二种方式，成员初始化的顺序可以改变。使代码更具有可移植性。</p>

<h4 id="file-struct">file struct</h4>

<p>struct file 是第二重要的数据结构，与用户空间的FILE完全没有关系</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">	<span class="n">mode_t</span> <span class="n">f_mode</span><span class="p">;</span><span class="c1">//mode_t is defined as __bitwise__</span>
	<span class="cm">/*The method 区分这个文件是可读的还是可写的*/</span>
	<span class="n">loff_t</span> <span class="n">f_ops</span><span class="p">;</span>
	<span class="cm">/*目前读和写的位置*/</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">f_flags</span><span class="p">;</span>
	<span class="cm">/*这是文件标志，such as O_RDONLY,O_NONBLACK,O_SYNC,当一个驱动询问是
	  否正在堵塞应该检查O_NONBLOCK标志位，所有的标志是被定义在&lt;linux/fcntl.h&gt;*/</span>
	<span class="k">struct</span> <span class="n">file_operations</span> <span class="o">*</span><span class="n">f_op</span><span class="p">;</span>
	<span class="cm">/*这是关于文件的，这一块很重要，但是我没有读懂什么意思，open操作
	  对应主设备号1,filp-&gt;p对应次设备号*/</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">private_data</span><span class="p">;</span>
	<span class="cm">/*这open系统呼叫在使用open方法之前设置了NULL？？，要记得释放*/</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">f_dentry</span><span class="p">;</span>
	<span class="cm">/*the directory entry (dentry) 和文件有关系，BTW，设备从来不创建file结构*/</span></code></pre></figure>

<h3 id="inode-structure">inode structure</h3>
<p>The inode 是被内核内部用来代表文件，单个文件可以有多个file结构，但是它们全都指向一个 inode,现在先有两个重要域关于驱动的</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">	<span class="n">dev_t</span> <span class="n">i_rdev</span><span class="p">;</span>
	<span class="cm">/*对于inode来说，它代表设备文件，包含实际的设备号*/</span>
	<span class="k">struct</span> <span class="n">cdev</span> <span class="o">*</span><span class="n">i_dev</span><span class="p">;</span>
	<span class="cm">/*struct cdev 是代表字符设备的内部结构*/</span></code></pre></figure>

<p>最近，有开发者希望能从inode中直接获取主设备号和次设备，</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unsigned int iminor(struct inode *inode);
unsigned int imajor(struct inode *inode);
</code></pre></div></div>

<h3 id="字符设备注册">字符设备注册</h3>
<p>在linux中，内核使用 cdev 结构去表示字符设备，那么必须包含&lt;linux/cdev.h&gt;,可以使用以下方法在运行时获得 cdev 结构，</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct cdev *my_cdev = cdev_alloc();
my_dev-&gt;ops = &amp;my_fops;
</code></pre></div></div>

<p>在初始化中,</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void cdev_init(struct cdev *cdev, struct file_operations *ops);
</code></pre></div></div>

<p>在kenel呼叫cdev是</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int cdev_add(struct cdev *dev, dev_t num, unsigned int count);
</code></pre></div></div>

<p>num是这个设备对应的第一设备号,count是设备号对应的设备的数量,多数情况下是1,也有例外的情况.这个函数失败的话会返回一个负数.</p>

<p>To remove a char device from the system ,call:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void cdev_del(struct cdev, *dev);
</code></pre></div></div>

<h2 id="device-registration-in-scull">Device Registration in scull</h2>
<p>scull 代表被一个scull_dev设备</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct scull_dev {
	strcut scull_qset *data; /*first quantum*/
	int quantum; /* The current quantum size*/
	int qset; /*the current array size*/
	unsigned long size; /*amount of data stored here*/
	unsigned int access_key;
	struct semaphore sem; /* mutual exclusion semaphore*/
				/*互斥信号量*/
	struct cdev cdev;/* Char device structure*/
}
</code></pre></div></div>

<p>struct cdev是设备加载到内核的接口,这个结构必须初始化和加进系统使用如下的方法,</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static void scull_setup_cdev(struct scull_cdev *dev, int index)
{
	int err, devno = MKDEV(struct scull_major, scull_mirror +
				index);
	cdev-&gt;init(&amp;dev-&gt;cdev, &amp;scull_fops);
	dev-&gt;cdev.owner = THIS_MOUDLE;
	dev-&gt;cdev.ops = &amp;scull_fops;
	err = cdev_add (&amp;dev-&gt;cdev, devno,1);
	if(err);
	printk(KERN_NOTICE "error %d adding scull%d",err,index);
}
</code></pre></div></div>

<h2 id="open">open()</h2>
<p>__open__method is provided for a driver to do any initialization in preparation for later operations,must consider following tasks:检查设备特别的错误,如没有就绪 Initialize the device if it is being opened for the first time
Update f_op pointer,Allocate and in filp-&gt;private_data</p>

<p>第一件事是确定哪个设备正在被打开,open的函数原型为</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int (*open)(struct inode *inode, struct file *file)
</code></pre></div></div>

<p>我们希望scull_dev结构包含cdev结构,(它这是在说什么), container_of defined is in &lt;linux/kernel.h&gt;</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>container_of(pointer, container_type, container_field);
</code></pre></div></div>

<p>这个宏把一个指针指向container_field的域,返回一个指针指向containing结构,在scull_open</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct scull_dev *dev; /*device information*/

dev = contain_of(inode-&gt;i_cdev,struct scull_dev, cdev);
filp-&gt;private_data = dev;
</code></pre></div></div>

<p>只要一发现scull_dev结构,scull把一个指向前者的指针储存在private_data( in file structure)</p>

<p>另一种方法是储存在 inode 结构体中的次设备号,尤其你使用register_chrdev方法注册设备,scull_open的代码如下:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int scull_open(struct inode *inode, struct file *file)
{
	struct scull_dev *dev; /* device information*/
	dev = contain_of(inode-&gt;i_cdev, struct scull_dev, cdev);
	filp-&gt;private_data =dev;/*for other methods */
	/*now trim to 0 the length of the device if open was write
	 -only*/
	if ( (filp-&gt;f_flags &amp; 0_ACCMODE) == 0_WRONLY) {
		scull_trim(dev);/*ignore errors*/
	}
	return 0; /* success*/


}
</code></pre></div></div>

<p>scull is a global structure.</p>

<h2 id="release">release</h2>
<p>这个函数的作用有两个:1.撤销任何已经分配给filp-&gt;private_data的数据,2. 最后一次关闭设备</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int scull_release(struct inode *inode, struct file *file)
{
	return 0;
}
</code></pre></div></div>

<p>因为没有硬件所以可以使用最简洁的方法去关闭scull.</p>

<p>如果一个设备文件关闭的次数比它打开的次数多会发生什么? (what happens when a device file is closed more times than it is opened),after all,dup和fork呼叫这open files不使用open,How to a driver know when an open device file has really been closed?</p>

<p>the answer is simple: not every close system call causes the release method to be invoked.the kernel keeps a counter of how many times a file structure is being used.Neither fork nor dup creates a new file structure (only open does that),They just increment the counter in the existing structure.The close system call executes the release method only when the file structure drops to 0,the guarantees that your driver sees only one release call for each open.</p>

<p>kernel automatically closes any file at process exit time by internally using the close system call.</p>

<p>##scull’s Memory Usage</p>

<p>two core functions used to manage memory in the Linux kernel.defined in &lt;linux/slab.h&gt;</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void *kmalloc(size_t size, int flags);
void kfree(void *ptr);
</code></pre></div></div>

<p>其中,size 是申请的字节大小,flags 在这里是GFP_KERNEL(又是一个多重的宏定义),稍后再详细解释这个东西.只要不使用kmalloc,就别使用kfree,当然,NULL可以传递给kfree.kmalloc 不是最有效的方法去申请内存,但这里只是为了简单展现是read和write的方法,申请整页的方法以后讲.</p>

<p>这里有好好几种方法改变quantum和quantum set的大小:1,改变宏SCULL_QUANTUM和SCULL_QSET.2.在加载模块的时候指定scull_quantum和scull_qset的大小.3.或者改变ioctl的大小.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct scull_qset {
	void **data;
	struct scull_qset *next;
}
</code></pre></div></div>

<p>下面的代码段展示了struct scull_dev和struct scull_qset如何持有data,__scull_trim__被scull_open激活.它遍历list和free   quantum和quantum set.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int scull_trim(struct scull_dev *dev)
{
	struct scull_qset *next, *dptr;
	int qset = dev-&gt;qset;
	int i;
	for (dptr = dev-&gt;data;dptr; dptr = next){
		/*all the list items*/
		if(dptr-&gt;data){
			for(i=0; i&lt;qset; i++)
				kfree(dptr-&gt;data[i]);
			kfree(dptr-&gt;data);
		}
		next = dptr-&gt;next;
		kfree(dptr);
	}
	dev-&gt;size = 0;
	dev-&gt;quantum = scull_quantum;
	dev-&gt;qset = scull_qset;
	dev-&gt;data = NULL;
	return 0;
}
</code></pre></div></div>

<h2 id="read-and-write">read and write</h2>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssize_t read (struct file *flip, char __user *buff,
		size_t count, loff_t *offp);
ssize_t write(struct file *filp, const char __user *buff,
		size_t count, loff_t *offp);
</code></pre></div></div>

<p>这里的buff是用户空间的数据,不能直接被kernel 的代码使用,为了能够在用户空间和内核空间传递buff,我们引入了特别的函数&lt;asm/uaccess.h&gt;,</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unsigned long copy_to_user(void __user *to,
			   const void *from,
			   unsigned long count);
unsigned long copy_from_user(void *to,
				const void __user, *from,
				unsigned long count);
</code></pre></div></div>

<p>需要注意的是,用户空间的地址可能不存在,这时你必须把该进程睡眠.你必须保证传递给这些函数的用户空间指针是合法的.:</p>

<h3 id="the-read-method">the read method</h3>
<p>A negative value is means an error,defined in &lt;linux/errono.h&gt;.typical values include -ETNTR(interrupted sytem call) -EFAULT(bad address).</p>

<h2 id="readv-and-writev">readv and writev</h2>
<p>These sysyem calls are versions of read and write taking an array of structures.each of which contains a pointer and a length value.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssize_t (*read) (struct file *filp,const struct iovec *iov,
		unsigned long count, loff_t *ppos);
ssize_t (*write) (struct file *filp, const struct iovec *iov,
		unsigned long count, loff_t *ppos);
</code></pre></div></div>

<p>Here,the filp and ppos arugments are the same as for read and write.The __iovec__structure,defined in &lt;linux/uio.h&gt;</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct iovec
{
	void __user *iov_base;
	__kernel_size_t iov_len;
};
</code></pre></div></div>

<p>__kernel_size_t__是unsigned long ,Each iovec describes one chunk of data to be transferred; it starts at iov_base(in user space) and is iov_len bytes long.The count parameter tells the method how many iovec structure there are.</p>


                </div>
                <div class="read-all">
                    <a  href="/2014/11/24/LinuxDeveicsDriver/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
              <li>
                <h2>
                  <a class="post-link" href="/2014/11/21/kernelPMAPI/">kernel进程管理API</a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2014-11-21
                    </div>
                    <div class="label-card">
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#kernel" title="Category: kernel" rel="category">kernel</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    <p>#函数
__task_pid_nr_ns(struct task_struct *task,enum pid_type type,struct pid_namespace *ns)
#文件包含
#include&lt;linux/sched.h&gt;
#函数定义
##在内核源代码的位置 linux-3.2.64/kernel/pid.c
##函数定义格式:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">pid_t</span> <span class="nf">__task_pid_nr_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">enum</span> <span class="n">pid_type</span> <span class="n">type</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">pid_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pid_t</span> <span class="n">nr</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ns</span><span class="p">)</span>
		<span class="n">ns</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">nsproxy</span><span class="o">-&gt;</span><span class="n">pid_ns</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">pid_alive</span><span class="p">(</span><span class="n">task</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="n">PIDTYPE_PID</span><span class="p">)</span>
			<span class="n">task</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="p">;</span>
		<span class="n">nr</span> <span class="o">=</span> <span class="n">pid_nr_ns</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">pid</span><span class="p">,</span><span class="n">ns</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">nr</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYSBOL</span><span class="p">(</span><span class="n">__task_pid_nr_ns</span><span class="p">);</span></code></pre></figure>

<p>#函数功能描述
此函数用于获取进程的进程号，但应该满足以下几个条件。
1.参数type如果不等于PIDTYPE_PID，则参数task用其所属任务组的第一个任务赋值，否则保持task不变。</p>

<p>2.此进程是参数task任务描述符的进程。</p>

<p>3.保证进程描述符和pid_namespaces和参数ns相同。</p>

<p>#参数补充(未写)</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cm">/*linux/pid.h*/</span>
<span class="k">enum</span> <span class="n">pid_type</span>
<span class="p">{</span>
	<span class="n">PIDTYPE_PID</span><span class="p">,</span> <span class="c1">//进程的进程号</span>
	<span class="n">PIDTYPE_PGID</span><span class="p">,</span> <span class="c1">//process group' leader process ID</span>
	<span class="n">PIDTYPE_SID</span><span class="p">,</span>  <span class="c1">//session' leader process ID</span>
	<span class="n">PIDTYPE_MAX</span>
<span class="p">};</span>
<span class="cm">/*
 *linux/pid_namespace.h
 */</span>
<span class="k">struct</span> <span class="n">pidmap</span> <span class="p">{</span>
	<span class="n">atomic_t</span> <span class="n">nr_free</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">struct</span> <span class="n">pid_namespace</span> <span class="p">{</span>
	<span class="cm">/*kerf is reference count,代表此命名空间在多少进程中被使用*/</span>
	<span class="k">struct</span> <span class="n">kref</span> <span class="n">kref</span><span class="p">;</span>
	<span class="cm">/*current system PID */</span>
	<span class="k">struct</span> <span class="n">pidmap</span> <span class="n">pidmap</span><span class="p">[</span><span class="n">PIDMAP_ENTRIES</span><span class="p">];</span>
	<span class="cm">/*上一次分配给进程的PID的值*/</span>
	<span class="kt">int</span> <span class="n">last_pid</span><span class="p">;</span>
	<span class="cm">/*保存指向该进程的struct_task的指针*/</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">child_reaper</span><span class="p">;</span>
	<span class="cm">/*指向该进程在cache中的分配空间*/</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">pid_cachep</span><span class="p">;</span>
	<span class="cm">/*初始化为0,从level内核可知进程关联多少ID*/</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">level</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pid_namespace</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_PROC_FS
</span>	<span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">proc_mnt</span><span class="p">;</span>
<span class="cp">#endif
#ifdef CONFIG_BSD_PROCESS_ACCT
</span>	<span class="k">struct</span> <span class="n">bsd_acct_struct</span> <span class="o">*</span><span class="n">bacct</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="p">};</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">pid_namespace</span> <span class="n">init_pid_ns</span><span class="p">;</span></code></pre></figure>

<p>#举例</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cm">/*
 *include head file
 */</span>
<span class="cp">#include &lt;linux/module.h&gt;
#include &lt;linux/sched.h&gt;
#include &lt;linux/pid.h&gt;
</span><span class="cm">/*
 *per 
 */</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">"GPL"</span><span class="p">);</span>
<span class="cm">/*
 *define subprocess function  
 */</span>
<span class="kt">int</span> <span class="nf">my_function</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">argc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">"&lt;0&gt;in the kernel thread function</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">__task_pid_nr_ns_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">"&lt;0&gt; into __task_pid_nr_ns_init.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="cm">/*
	 *Create a new process
	 */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">kernel_thread</span><span class="p">(</span><span class="n">my_function</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="n">CLONE_KERNEL</span><span class="p">);</span>
	<span class="cm">/*
	 *get subprocess pid
	 */</span>
	<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">kpid</span> <span class="o">=</span> <span class="n">find_get_pid</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
	<span class="cm">/*
	 *get 进程所属的任务描述符
	 */</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="n">pid_task</span><span class="p">(</span><span class="n">kpid</span><span class="p">,</span> <span class="n">PIDTYPE_PID</span><span class="p">);</span>
	<span class="cm">/*
	 *获取任务对应进程的进程描述符
	 */</span>
	<span class="n">pid_t</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">__task_pid_nr_ns</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">PIDTYPE_PID</span><span class="p">,</span> <span class="n">kpid</span><span class="o">-&gt;</span><span class="n">numbers</span><span class="p">[</span><span class="n">kpid</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">].</span><span class="n">ns</span><span class="p">);</span>
	<span class="cm">/*
	 *显示返回值的进程号
	 *
	 */</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">"&lt;0&gt; the pid of the find_get_pid is :%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">kpid</span><span class="o">-&gt;</span><span class="n">numbers</span><span class="p">[</span><span class="n">kpid</span> <span class="o">-&gt;</span> <span class="n">level</span><span class="p">].</span><span class="n">nr</span><span class="p">);</span>
	<span class="cm">/*
	 *显示函数find_get_pid()返回值的进程描述符
	 */</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">"&lt;0&gt; the result of __task_pid_nr_ns is :%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">result1</span><span class="p">);</span>
	<span class="cm">/*
	*显示函数kernel_thread()的返回值
	*/</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">"&lt;0&gt; the result of kernel_thread is :%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">result</span><span class="p">);</span>
	<span class="cm">/*显示当前进程号
	   */</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">"&lt;0&gt; the pid of current thread is :%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">"&lt;0&gt; out __task_pid_nr_ns_init.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">__task_pid_nr_ns_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">"&lt;0&gt; Goobye __task_pid_nr_ns</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*
 *load and exit
 */</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">__task_pid_nr_ns_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">__task_pid_nr_ns_exit</span><span class="p">);</span></code></pre></figure>

<p>结合以前的知识，写出Makefile，执行</p>

<p><strong>make</strong></p>

<p>然后，键入</p>

<p>insmod __task_pid_nr_ns.ko</p>

<p>这时一般终端就会有消息产出，如果没有可以接着使用 __dmesg -c__命令
##终端信息</p>
<pre>
Message from syslogd@debian at Nov 21 15:28:12 ...
 kernel:[  458.244921]  into __task_pid_nr_ns_init.

Message from syslogd@debian at Nov 21 15:28:12 ...
 kernel:[  458.244971]  the pid of the find_get_pid is :2915

Message from syslogd@debian at Nov 21 15:28:12 ...
 kernel:[  458.244980]  the result of __task_pid_nr_ns is :2915

Message from syslogd@debian at Nov 21 15:28:12 ...
 kernel:[  458.244988]  the result of kernel_thread is :2915

Message from syslogd@debian at Nov 21 15:28:12 ...
 kernel:[  458.244995]  the pid of current thread is :2914

Message from syslogd@debian at Nov 21 15:28:12 ...
 kernel:[  458.245002]  out __task_pid_nr_ns_init.

Message from syslogd@debian at Nov 21 15:28:12 ...
 kernel:[  458.245964] in the kernel thread function
dmesg -c
dmesg: klogctl failed: 不允许的操作
yubo@debian:~/linux/process$ 
</pre>
<p>#find_get_pid()
定义:struct pid *find_get_pid(int nr)
##功能
此函数根据提供的进程号获取对应的进程描述符，并使进程描述符的count的值加1即此进程的用户数加1</p>

<p>##参数说明
nr即为进程号
##返回参数
返回与参数提供的进程号对应的进程描述符，进程描述符定义如下：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">pid</span> <span class="p">{</span>
	<span class="cm">/*此进程的任务数*/</span>
	<span class="n">atomic_t</span> <span class="n">count</span><span class="p">;</span>
	<span class="cm">/*level对应成员number[]的下标，一般取值为0*/</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">level</span><span class="p">;</span>
	<span class="cm">/*此进程的任务列表*/</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="n">tasks</span><span class="p">[</span><span class="n">PIDTYPE_MAX</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">rcu</span><span class="p">;</span>
	<span class="cm">/*struct upid类型的数组*/</span>
	<span class="k">struct</span> <span class="n">upid</span> <span class="n">numbers</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">uoid</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">nr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pid_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">pid_chain</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">pid</span> <span class="n">init_struct_pid</span><span class="p">;</span></code></pre></figure>

<p>##find_get_pid()应用举例</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include &lt;linux/module.h&gt;
#include &lt;linux/sched.h&gt;
#include &lt;linux/pid.h&gt;
</span><span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">"GPL"</span><span class="p">);</span>

<span class="cm">/*
 * define subprocess
 */</span>
<span class="kt">int</span> <span class="nf">my_function</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">argc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">"&lt;0&gt; in the kerenl thread function!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
 * load module function
 *
 */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">find_get_pid_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">"&lt;0&gt; into the find_get_pid_init.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="cm">/*
	 * create a new process, the value of return is a int num,also called 
	 * process id  
	 */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">kernel_thread</span><span class="p">(</span><span class="n">my_function</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="n">CLONE_KERNEL</span><span class="p">);</span>
	<span class="cm">/*
	 * According to process id,call zhe function,get the process descriptor
	 * information, wait ...atomc_t？
	 */</span>
	<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">kpid</span> <span class="o">=</span> <span class="n">find_get_pid</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
	<span class="cm">/*
	 * how many time use the function
	 */</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">"&lt;0&gt; the count of the pid is :%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">kpid</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
	<span class="cm">/*
	 * level
	 */</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">"&lt;0&gt; the level of the pid is :%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">kpid</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">);</span>

	<span class="cm">/*
	 * display PID
	 */</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">"&lt;0&gt; the pid of the find_get_pid is :%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">kpid</span><span class="o">-&gt;</span><span class="n">numbers</span><span class="p">[</span><span class="n">kpid</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">].</span><span class="n">nr</span><span class="p">);</span>
	<span class="cm">/*
	 * display kernel_thread's return value
	 */</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">"&lt;0&gt; the result of the kernel_thread is :%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">result</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">"&lt;0&gt; out find_get_pid_init.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>	
<span class="p">}</span>
<span class="cm">/*
 * quit module define
 */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">find_get_pid_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">"&lt;0&gt; Goodbye find_get_pid"</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">find_get_pid_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">find_get_pid_exit</span><span class="p">);</span></code></pre></figure>

<p>##输出结果</p>
<pre>
Message from syslogd@debian at Nov 23 05:42:16 ...
 kernel:[ 3162.689851]  into the find_get_pid_init.

Message from syslogd@debian at Nov 23 05:42:16 ...
 kernel:[ 3162.689863]  the count of the pid is :2

Message from syslogd@debian at Nov 23 05:42:16 ...
 kernel:[ 3162.689864]  the level of the pid is :0

Message from syslogd@debian at Nov 23 05:42:16 ...
 kernel:[ 3162.689866]  the pid of the find_get_pid is :3554

Message from syslogd@debian at Nov 23 05:42:16 ...
 kernel:[ 3162.689867]  the result of the kernel_thread is :3554

Message from syslogd@debian at Nov 23 05:42:16 ...
 kernel:[ 3162.689868]  out find_get_pid_init.

Message from syslogd@debian at Nov 23 05:42:16 ...
 kernel:[ 3162.690635]  in the kerenl thread function!
</pre>

                </div>
                <div class="read-all">
                    <a  href="/2014/11/21/kernelPMAPI/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
              <li>
                <h2>
                  <a class="post-link" href="/2014/11/20/StartBusiness/">创业</a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2014-11-20
                    </div>
                    <div class="label-card">
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#experience" title="Category: experience" rel="category">experience</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    <p>看到一篇好的<a href="http://www.cnblogs.com/youxin/archive/2011/11/06/2238535.html">!文章</a>，转过来。</p>
<h1 id="导读">导读</h1>

<p>如果你认为自己是互联网中的一员（业内人士或普通用户），想想自己是不是每天都徘沉溺于各种社区和同行、朋友、同学互动？是不是时时不忘阅读各种新鲜、热辣、搞笑的文章？是不是频繁参加业内各种各样的研讨会、聚会活动，有时候还会为没赶上而懊恼？真的需要这些吗？自己从这里面真正得到收获了吗？</p>

<p>本文是从 What I Wish Someone Had Told Me 4 Years Ago 翻译而来，作者是一个创业者，之前在微软工作。文章主要讲述了作者对创业、做事、时间管理、面对失败的感悟，以及一些优秀的建议。读罢此文，我觉得有必要和大家一起分享作者的这些经验。文章提到的这些，至少我是比较认同的。当你开始思考这些时，你会发现，原来自己一直都陷入了一个误区——看别人表演。</p>

<p>嗯，是时候开始行动了！</p>

<h1 id="正文">正文</h1>

<p>就在2007年，我毅然离开了微软，加入了创业者的队伍。像很多第一次创业的人一样，我对这种冒险非常的兴奋。同样也跟很多第一次创业的人一样，我茫然没有头绪。</p>

<p>我参加各种活动，聚会，研讨会，和西雅图本地的创业社区密切交往。当我到了硅谷后，我发现这里有更多的活动，聚会，更多的研讨会。在这个创业生态系统里，一切很忙、很活跃，我收获了大量的人们共享出来的知识和体验，我如饥似渴的享用着。</p>

<p>我还满腔热情的看了很多的博客，视频和书籍。活动、聚会、研讨会中人们分享和讨论的都是非常好的主题。</p>

<p>我甚至还加入了一个创业孵化机构！</p>

<p>直到决定开办自己的公司时，我才意识到，所有我的阅读、观看、参加的活动实际上没有给我带来任何的用处。我是认真的。完全没有任何用处。大部分我学到的东西都想不起来了，剩下一点能记住的也很少能应用到我现在的处境里。学习他人的经验和成功对我就像是在吃快餐，像是吃那些味道很好的垃圾食品，让我膨胀，让我自满。抱歉我在泼冷水，但这是事实。</p>

<p>起初，我努力把我学到的东西应用到我自己的问题里。不灵。这不可思议的时刻真的到来了，我平静的接受了这个事实：我浪费了大量的时间去学了一些根本不需要的东西，我相信有人说过的一句话正是在嘲笑我的这些行为：所有的这些活动，研讨会，博客文章都只是用来多拖延你一天立即行动的另一个借口。我默默的接受这个事实，以一个新手的心情往前走，沿着这个方向，我相信我将会理解出什么才是我需要的。</p>

<p>所有的变化由此而来。</p>

<p>我们每个人身上都有一种东西，想在这种存在着不确定性、具有风险的创业冒险活动中创造，成就，前进。但我们还有另外一种东西，每个人都希望能感到确定，可靠，让我们能做出正确的决策，让我们在这条道路上不至于失败、使自己受伤。矛盾冲突就是从此产生的。</p>

<p>可是这些博客，活动，访谈并不能真正的消解这些矛盾。只是暂时的，它让我知道，有很多人在做和我同样的事情，让我放松。去创业是让我走出我的安逸环境，而我所做的只是从一个安逸环境跳到另外一个安逸环境。你知道吗？我就职于一个不错的公司！</p>

<p>一天，我反省一下我目前的状况，发现自己忙于很多事情，唯独没有把时间用于自己的产品上。几个月后，我终于鼓足勇气对自己说：这唯一重要的事情是真正的坐下来去做事。</p>

<p>别误会。我觉得有些博客和研讨会还是有价值的。但除非你真正的去实施什么事情、给你所学所扩展的关系网创造一个用武之地，你就是在浪费你的宝贵时间。</p>

<p>下面就是一些帮助了我去克服这“创业困惑综合征”的东西：</p>

<p>1、我数周内不再阅读创业新闻和博客，我意识到对于我的产品我不缺任何东西。至于谁又获得了融资，谁被收购了，以及为什么在Google Chrome的竞争下IE丧失了它的市场份额，这跟我没有任何关系。我唯一要关心的人是客户，我唯一要关心的事情是他们的需求和愿望、如何提供他们最有价值的东西。</p>

<p>2、我数月不去参加那些创业相关的活动，而且开始通过咖啡和酒去交接朋友。每月我仍可能会去参加一两个活动，但那只是为了娱乐。我不再迷惑于为了成为一个企业家而且参加那些创业相关的活动。</p>

<p>3、我通过小项目来实践学习。我把一些想法细化成容易管理的细目，给自己设定期限去完成它们。项目和试验品是神奇的教学工具，因为你在学习你想要的，你在获得第一手资料。就像Keynotopia这个项目极大的帮助了我产生灵感，形成思路，我可以看见它，和它交互，展示给别人——这就是我首先要把它做出来的原因！有时一些小项目还可以让你获得不少收入。</p>

<p>4、每走一步，我都准备好一个问题清单，它能让我知道下一步该往哪里走。是该去获得更多的访问量？改进产品？还是在不提高访问量的情况下提高收入？我整理出最好的问题，然后研究它，咨询人们，然后把获得的答案立即付诸于行动。这些信息我都不会让它们在我的大脑里转的太久。</p>

<p>5、这是我的最爱：我更多的恐惧是产生于没有去行动，而不是相反的害怕去行动。我认识到，晚一天我没有让客户接受我的方案，竞争对手就多一天的机会比我先达到客户要求。我甚至设想到了如果我不能行动起来，最终将会看到最可怕的噩梦：从办公室又回到密尔顿，在Innotech的小隔间里饱食终日，拿着那个红色的订书机，等着下一次的发薪日。这正是我需要的充满魔力的紧迫感。</p>

<p>6、我第一是要把事情完成，然后才是把事情办对。我知道（深受教训），做事的劲头重要无比。如果你在得到一个想法后不能立即付诸实施，最终很有可能的结局是这个想法被束之高阁。如今不论何时我得到了一个想法，我会盯着它让它成为现实，让它变成实际。我立即行动，虽然方式不成熟，但之后想办法改进，这样就学会了自己真正需要的东西。</p>

<p>7、面对现实：如果你不走出你的安逸环境、动手去干，什么事情都不会发生。等待再等待，罕有行动。</p>

<p>我想留给你们一句改变了我的生活的名言：成功的人并不是一定比别人更有才智和更幸运。他们只是在不断的尝试、不断的失败，直到成功。</p>

<p>不要做想象中的企业家，用行动和成果成为企业家。</p>

<h1 id="后记">后记</h1>

<p>不知道各位是否体会到了作者的用心，他用他的经历告诉我们，只有真正坐下来做事，才是取得成功的唯一途径。说，没有用；行动，才是最重要的。</p>

<p>与君分享</p>

<h1 id="项目">项目</h1>

<p>目前我能想到的是做一个有关咨询的网站，目标是社会中产阶级，利用自己的优势去帮助
他们更好的理解国家政策法规、海外的投资机会，应该不是什么难的项目。</p>

<h3 id="步骤">步骤</h3>
<p>从邮件列表开始</p>

                </div>
                <div class="read-all">
                    <a  href="/2014/11/20/StartBusiness/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
        </ul>



        <!-- Pagination links -->
        <div class="pagination">
          
            <a href="/index.html" class="previous"><i class="fa fa-angle-double-left"></i></a>
            <a href="/page30" class="previous"><i class="fa fa-angle-left"></i></a>
          
          <span class="page_number ">31/36</span>
          
            <a href="/page32" class="next"><i class="fa fa-angle-right"></i></a>
            <a href="/page36" class="next"><i class="fa fa-angle-double-right"></i></a>
          
        </div>
    </div>
    <!-- <button class="anchor"><i class="fa fa-anchor"></i></button> -->
    <div class="right">
        <div class="wrap">
            <div class="side">
                <div>
                    <i class="fa fa-pencil-square-o" aria-hidden="true"></i>
                    Recent Posts
                </div>
                <ul class="content-ul" recent>
                    
                        <li><a href="/2018/09/20/blog-update-themes/">blog更换主题</a></li>
                    
                        <li><a href="/2018/09/16/debian-desktop/">debian桌面系统</a></li>
                    
                        <li><a href="/2018/08/31/sdn_summary/">SDN之OVS学习</a></li>
                    
                        <li><a href="/2018/06/12/git-push/">git pull-request使用简介</a></li>
                    
                        <li><a href="/2018/06/04/libvirt-trouble-summary/">libvirt问题汇总</a></li>
                    
                        <li><a href="/2018/06/03/ebpf-kernel/">ebpf基础知识</a></li>
                    
                        <li><a href="/2018/06/02/neomutt-imap-126/">Neomutt使用126邮箱的imap</a></li>
                    
                        <li><a href="/2018/05/22/leetcode-easy/">leetcode easy task</a></li>
                    
                        <li><a href="/2018/05/21/xdp-introducation/">xdp简介</a></li>
                    
                        <li><a href="/2018/05/13/bpf-bcc/">BPF-bcc usage</a></li>
                    
                </ul>
            </div>

            <!-- Content -->
            <div class="side ">
                <div>
                    <i class="fa fa-th-list"></i>
                    Categories
                </div>
                <ul class="content-ul" cate>
                    
                    <li>
                        <a href="/category/#experience" class="categories-list-item" cate="experience">
                            <span class="name">
                                experience
                            </span>
                            <span class="badge">5</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#debian" class="categories-list-item" cate="debian">
                            <span class="name">
                                debian
                            </span>
                            <span class="badge">5</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#tools" class="categories-list-item" cate="tools">
                            <span class="name">
                                tools
                            </span>
                            <span class="badge">28</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#plan" class="categories-list-item" cate="plan">
                            <span class="name">
                                plan
                            </span>
                            <span class="badge">3</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#algorithm" class="categories-list-item" cate="algorithm">
                            <span class="name">
                                algorithm
                            </span>
                            <span class="badge">2</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#DS" class="categories-list-item" cate="DS">
                            <span class="name">
                                DS
                            </span>
                            <span class="badge">8</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#mood" class="categories-list-item" cate="mood">
                            <span class="name">
                                mood
                            </span>
                            <span class="badge">7</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#OS" class="categories-list-item" cate="OS">
                            <span class="name">
                                OS
                            </span>
                            <span class="badge">5</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#shell" class="categories-list-item" cate="shell">
                            <span class="name">
                                shell
                            </span>
                            <span class="badge">8</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#kernel" class="categories-list-item" cate="kernel">
                            <span class="name">
                                kernel
                            </span>
                            <span class="badge">26</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#book" class="categories-list-item" cate="book">
                            <span class="name">
                                book
                            </span>
                            <span class="badge">5</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#git" class="categories-list-item" cate="git">
                            <span class="name">
                                git
                            </span>
                            <span class="badge">12</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#c" class="categories-list-item" cate="c">
                            <span class="name">
                                c
                            </span>
                            <span class="badge">13</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#perl" class="categories-list-item" cate="perl">
                            <span class="name">
                                perl
                            </span>
                            <span class="badge">5</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#assembly" class="categories-list-item" cate="assembly">
                            <span class="name">
                                assembly
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#make" class="categories-list-item" cate="make">
                            <span class="name">
                                make
                            </span>
                            <span class="badge">3</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#python" class="categories-list-item" cate="python">
                            <span class="name">
                                python
                            </span>
                            <span class="badge">18</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#java" class="categories-list-item" cate="java">
                            <span class="name">
                                java
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#mysql" class="categories-list-item" cate="mysql">
                            <span class="name">
                                mysql
                            </span>
                            <span class="badge">2</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#network" class="categories-list-item" cate="network">
                            <span class="name">
                                network
                            </span>
                            <span class="badge">8</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#unix" class="categories-list-item" cate="unix">
                            <span class="name">
                                unix
                            </span>
                            <span class="badge">10</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#css" class="categories-list-item" cate="css">
                            <span class="name">
                                css
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#dhc" class="categories-list-item" cate="dhc">
                            <span class="name">
                                dhc
                            </span>
                            <span class="badge">4</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#javascript" class="categories-list-item" cate="javascript">
                            <span class="name">
                                javascript
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#oracle" class="categories-list-item" cate="oracle">
                            <span class="name">
                                oracle
                            </span>
                            <span class="badge">3</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#system" class="categories-list-item" cate="system">
                            <span class="name">
                                system
                            </span>
                            <span class="badge">5</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#english" class="categories-list-item" cate="english">
                            <span class="name">
                                english
                            </span>
                            <span class="badge">2</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#writing" class="categories-list-item" cate="writing">
                            <span class="name">
                                writing
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#math" class="categories-list-item" cate="math">
                            <span class="name">
                                math
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#word" class="categories-list-item" cate="word">
                            <span class="name">
                                word
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#leetcode" class="categories-list-item" cate="leetcode">
                            <span class="name">
                                leetcode
                            </span>
                            <span class="badge">4</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#H4X0r" class="categories-list-item" cate="H4X0r">
                            <span class="name">
                                H4X0r
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#django" class="categories-list-item" cate="django">
                            <span class="name">
                                django
                            </span>
                            <span class="badge">2</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#life" class="categories-list-item" cate="life">
                            <span class="name">
                                life
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#nft" class="categories-list-item" cate="nft">
                            <span class="name">
                                nft
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#kvms" class="categories-list-item" cate="kvms">
                            <span class="name">
                                kvms
                            </span>
                            <span class="badge">2</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#patent" class="categories-list-item" cate="patent">
                            <span class="name">
                                patent
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#bpf" class="categories-list-item" cate="bpf">
                            <span class="name">
                                bpf
                            </span>
                            <span class="badge">3</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#xdp" class="categories-list-item" cate="xdp">
                            <span class="name">
                                xdp
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#sdn" class="categories-list-item" cate="sdn">
                            <span class="name">
                                sdn
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                </ul>
            </div>
            <!-- 其他div框放到这里 -->
            <div class="side">
                <div>
                    <i class="fa fa-tags"></i>
                    Tags
                </div>
                <div class="tags-cloud">
                    
                    
                    
                    

                    

                    
                      
                      
                      
                      
                      
                      <a href="/tag/#experience" style="font-size: 18pt; color: #000;">experience</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#CS" style="font-size: 9pt; color: #999;">CS</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#English" style="font-size: 9pt; color: #999;">English</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#linux" style="font-size: 9pt; color: #999;">linux</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#mood" style="font-size: 9pt; color: #999;">mood</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#She" style="font-size: 9pt; color: #999;">She</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#FreeDos" style="font-size: 9pt; color: #999;">FreeDos</a>
                    
                </div>
            </div>

            <!-- <div class="side">
                <div>
                    <i class="fa fa-external-link"></i>
                    Links
                </div>
                <ul  class="content-ul">

                </ul>
            </div> -->
        </div>
    </div>
</div>
<!-- <script src="/js/scroll.min.js " charset="utf-8"></script> -->
<!-- <script src="/js/pageContent.js " charset="utf-8"></script> -->


    <footer class="site-footer">


    <div class="wrapper">

        <p class="description">
             技术笔记！ 
        </p>
        <p class="contact">
            Contact me at: 
            <a href="https://github.com/yuzibo" title="GitHub"><i class="fa fa-github" aria-hidden="true"></i></a>  
            <a href="mailto:yuzibode@126.com" title="email"><i class="fa fa-envelope-o" aria-hidden="true"></i></a>        
        </p>
        <p>
            本站总访问量<span id="busuanzi_value_site_pv"></span>次，本站访客数<span id="busuanzi_value_site_uv"></span>人次，本文总阅读量<span id="busuanzi_value_page_pv"></span>次
        </p>
        <p class="power">
            <span>
                Site powered by <a href="https://jekyllrb.com/">Jekyll</a> & <a href="https://pages.github.com/">Github Pages</a>.
            </span>
            <span>
                Theme designed by <a href="https://github.com/Gaohaoyang">HyG</a>.
            </span>
        </p>
    </div>
</footer>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <div class="back-to-top">
    <a href="#top" data-scroll>
        <i class="fa fa-arrow-up" aria-hidden="true"></i>
    </a>
</div>

    <script type="text/javascript" charset="utf-8" src="https://changyan.itc.cn/js/lib/jquery.js"></script>
    <script src=" /js/main.js " charset="utf-8"></script>
    <script src=" /js/prism.js " charset="utf-8"></script>
    <script src=" /js/smooth-scroll.min.js " charset="utf-8"></script>
    <script type="text/javascript">
      smoothScroll.init({
        speed: 500, // Integer. How fast to complete the scroll in milliseconds
        easing: 'easeInOutCubic', // Easing pattern to use
        offset: 20, // Integer. How far to offset the scrolling anchor location in pixels
      });
    </script>
    <script type="text/javascript">
	$('pre').addClass("line-numbers");
    </script>
    <!-- <script src=" /js/scroll.min.js " charset="utf-8"></script> -->
  </body>

</html>
